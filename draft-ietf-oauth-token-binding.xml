<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
"http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd">

<rfc category="std" docName="draft-ietf-oauth-token-binding-06" ipr="trust200902">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="5" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="yes" ?>
  <?rfc compact="yes" ?>
  <?rfc subcompact="no" ?>

  <front>
    <title abbrev="OAuth 2.0 Token Binding">OAuth 2.0 Token Binding</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
	<uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="Brian Campbell" initials="B." surname="Campbell">
      <organization>Ping Identity</organization>
      <address>
        <email>brian.d.campbell@gmail.com</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Yubico</organization>
      <address>
        <email>ve7jtb@ve7jtb.com</email>
	<uri>http://www.thread-safe.com/</uri>
      </address>
    </author>


   <author fullname="William Denniss" initials="W." surname="Denniss">
      <organization>Google</organization>
      <address>
        <postal>
          <street>1600 Amphitheatre Pkwy</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>USA</country>
        </postal>
        <email>wdenniss@google.com</email>
        <uri>http://wdenniss.com/</uri>
      </address>
    </author>

    <date day="26" month="October" year="2017" />

    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>

    <keyword>OAuth</keyword>
    <keyword>Token Binding</keyword>
    <keyword>Proof-of-Possession</keyword>
    <keyword>PoP</keyword>

    <abstract>
      <t>
	This specification enables OAuth 2.0 implementations to apply
	Token Binding to Access Tokens, Authorization Codes, Refresh Tokens,
  JWT Authorization Grants, and JWT Client Authentication.
  This cryptographically binds these tokens to a client's Token Binding key
  pair, possession of which is proven on the TLS connections over which the
  tokens are intended to be used.
  This use of Token Binding protects these tokens
  from man-in-the-middle and token export and replay attacks.
       </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
	This specification enables OAuth 2.0 <xref target="RFC6749"/> implementations to apply
	Token Binding (<xref target="I-D.ietf-tokbind-negotiation">
  TLS Extension for Token Binding Protocol Negotiation</xref>,
	<xref target="I-D.ietf-tokbind-protocol">The Token Binding Protocol Version 1.0</xref>
	and <xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>)
  to Access Tokens, Authorization Codes, Refresh Tokens,
  JWT Authorization Grants, and JWT Client Authentication.
  This cryptographically binds these tokens to a client's Token Binding key
  pair, possession of which is proven on the TLS connections over which the
  tokens are intended to be used.
	This use of Token Binding protects these tokens
	from man-in-the-middle and token export and replay attacks.
      </t>

      <section anchor="rnc" title="Requirements Notation and Conventions">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL"
  in this document are to be interpreted as described in
  BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
  when, and only when, they appear in all capitals, as shown here.</t>
      </section>

      <section anchor="Terminology" title="Terminology">
	<t>
	  This specification uses the terms "Access Token", "Authorization Code",
	  "Authorization Endpoint", "Authorization Server",
	  "Client", "Protected Resource", "Refresh Token",
	  and "Token Endpoint"
	  defined by <xref target="RFC6749">OAuth 2.0</xref>,
	  the terms "Claim" and "JSON Web Token (JWT)"
	  defined by <xref target="JWT">JSON Web Token (JWT)</xref>,
	  the term "User Agent" defined by <xref target="RFC7230">RFC 7230</xref>,
	  and
	  the terms "Provided", "Referred", "Token Binding" and "Token Binding ID"
	  defined by <xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
	</t>
      </section>
    </section>

    <section anchor="RefreshTokenBinding" title="Token Binding for Refresh Tokens">
      <t>
	Token Binding of refresh tokens is a straightforward first-party scenario,
	applying term "first-party" as used in
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
  It cryptographically binds the refresh token to the client's Token Binding key
  pair, possession of which is proven on the TLS connections between the
  client and the token endpoint.
	This case is straightforward because the refresh token is
	both retrieved by the client from the token endpoint
	and sent by the client to the token endpoint.
	Unlike the federated scenarios described in
	Section 4 (Federation Use Cases) of 
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>
	and the access token case described in the next section,
	only a single TLS connection is involved in the refresh token case.
      </t>
      <t>
	Token Binding a refresh token requires that the authorization server do two things.
	First, when refresh token is sent to the client, the authorization server needs to
	remember the Provided Token Binding ID
	and remember its association with the issued refresh token.
	Second, when a token request containing a refresh token is received at the token endpoint,
	the authorization server needs to verify that
	the Provided Token Binding ID for the request
	matches the remembered Token Binding ID associated with the refresh token.
	If the Token Binding IDs do not match,
	the authorization server should return an error in response to the request.
      </t>
      <t>
	How the authorization server remembers the association
	between the refresh token and the Token Binding ID
	is an implementation detail that beyond the scope of this specification.
	Some authorization servers will choose to store the Token Binding ID
	(or a cryptographic hash of it, such a SHA-256 hash <xref target="SHS"/>)
  in the refresh token itself, provided it is integrity-protected,
  thus reducing the amount of state to be kept by the server.
	Other authorization servers will add the Token Binding ID value (or a hash of it)
	to an internal data structure also containing other information about the refresh token,
	such as grant type information.
	These choices make no difference to the client, since the refresh token is opaque to it.
      </t>
    <section anchor="RefreshTokenBindingEx" title="Example Token Binding for Refresh Tokens">
    <t>
      This section provides an example of what the interactions around a
      Token Bound refresh token might look like, along with some details of
      the involved processing. Token Binding of refresh tokens is most useful
      for native application clients so the example has protocol elements typical
      of a native client flow.
      Extra line breaks in all examples are for
      display purposes only.
    </t>

    <t>
      A native application client makes the following access token request with an
      authorization code using a TLS connection where Token
      Binding has been negotiated. A PKCE <spanx style="verb">code_verifier</spanx> is
      included because use of PKCE is considered best practice for native
      application clients <xref target="BCP212"/>.
      The base64url-encoded representation of
      the exported keying material (EKM) from that TLS connection is
      <spanx style="verb">p6ZuSwfl6pIe8es5KyeV76T4swZmQp0_awd27jHfrbo</spanx>, which is
      needed to validate the Token Binding Message.
    </t>

      <figure title="Initial Request with Code" anchor="RTEX1">
        <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: AIkAAgBBQGto7hHRR0Y5nkOWqc9KNfwW95dEFmSI_tCZ_Cbl
   7LWlt6Xjp3DbjiDJavGFiKP2HV_2JSE42VzmKOVVV8m7eqAAQOKiDK1Oi0z6v4X5B
   P7uc0pFestVZ42TTOdJmoHpji06Qq3jsCiCRSJx9ck2fWJYx8tLVXRZPATB3x6c24
   aY0ZEAAA

 grant_type=authorization_code&code=4bwcZesc7Xacc330ltc66Wxk8EAfP9j2
   &code_verifier=2x6_ylS390-8V7jaT9wj.8qP9nKmYCf.V-rD9O4r_1
   &client_id=example-native-client-id
]]></artwork>
      </figure>

    <t>
      A refresh token is issued in response to the prior request. Although it
      looks like a typical response to the client, the authorization server
      has bound the refresh token to the Provided Token Binding ID from the
      encoded Token Binding message in the <spanx style="verb">Sec-Token-Binding</spanx>
      header of the request. In this example,
      that binding is done by saving the Token Binding
      ID alongside other information about the refresh token in some server
      side persistent storage.
      The base64url-encoded representation of that Token Binding ID is
      <spanx style="verb">AgBBQGto7hHRR0Y5nkOWqc9KNfwW95dEFmSI_tCZ_Cbl7LWlt6Xjp3DbjiDJavGFiKP2HV_2JSE42VzmKOVVV8m7eqA</spanx>.

    </t>
    <figure title="Successful Response" anchor="RTEX2">
      <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"EdRs7qMrLb167Z9fV2dcwoLTC",
  "refresh_token":"ACClZEIQTjW9arT9GOJGGd7QNwqOMmUYfsJTiv8his4",
  "token_type":"Bearer",
  "expires_in":3600
 }
]]></artwork>
    </figure>

  <t>
    When the access token expires, the client requests a new one with
    a refresh request to the token endpoint. In this example, the request is made on a new
    TLS connection so the EKM (base64url-encoded:
    <spanx style="verb">va-84Ukw4Zqfd7uWOtFrAJda96WwgbdaPDX2knoOiAE</spanx>)
    and signature in the Token Binding Message are different than in the
    initial request.
  </t>

      <figure title="Refresh Request" anchor="RTEX3">
        <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: AIkAAgBBQGto7hHRR0Y5nkOWqc9KNfwW95dEFmSI_tCZ_Cbl
   7LWlt6Xjp3DbjiDJavGFiKP2HV_2JSE42VzmKOVVV8m7eqAAQCpGbaG_YRf27qOra
   L0UT4fsKKjL6PukuOT00qzamoAXxOq7m_id7O3mLpnb_sM7kwSxLi7iNHzzDgCAkP
   t3lHwAAA

 refresh_token=ACClZEIQTjW9arT9GOJGGd7QNwqOMmUYfsJTiv8his4
   &grant_type=refresh_token&client_id=example-native-client-id
]]></artwork>
      </figure>

<t>
  However, because the Token Binding ID is long-lived and may span multiple TLS
  sessions and connections, it is the same as in the initial request. That
  Token Binding ID is what the refresh token is bound to, so the authorization
  server is able to verify it and issue a new access token.
</t>
      <figure title="Successful Response" anchor="RTEX4">
        <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"bwcESCwC4yOCQ8iPsgcn117k7",
  "token_type":"Bearer",
  "expires_in":3600
 }
]]></artwork>
      </figure>
    </section>
    </section>


    <section anchor="AccessTokenBinding" title="Token Binding for Access Tokens">
      <t>
  Token Binding for access tokens cryptographically binds the access token
  to the client's Token Binding key
  pair, possession of which is proven on the TLS connections between the
  client and the protected resource.
	Token Binding is applied to access tokens in a similar manner to that
	described in Section 4 (Federation Use Cases) of 
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
	It also builds upon the mechanisms for Token Binding of ID Tokens defined in
	<xref target="OpenID.TokenBinding">OpenID Connect Token Bound Authentication 1.0</xref>.
      </t>
      <t>
	In the <xref target="OpenID.Core">OpenID Connect</xref> use case,
	HTTP redirects are used to pass information
	between the identity provider and the relying party;
	this HTTP redirect makes the Token Binding ID of the relying party
	available to the identity provider as the Referred Token Binding ID,
	information about which is then added to the ID Token.
	No such redirect occurs between the authorization server and the protected resource
	in the access token case;
	therefore, information about the Token Binding ID for the TLS connection
	between the client and the protected resource needs to be explicitly
	communicated by the client to the authorization server to achieve Token Binding
	of the access token.
      </t>
      <t>
	This information is passed to the authorization server
	using the Referred Token Binding ID, just as in the ID Token case.
	The only difference is that the client needs to explicitly
	communicate the Token Binding ID of
	the TLS connection between the client and the protected resource
	to the Token Binding implementation so that it is sent as
	the Referred Token Binding ID in the request to the authorization server.
	This functionality provided by Token Binding implementations is described in
	Section 5 (Implementation Considerations) of
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
      </t>
      <t>
	Note that to obtain this Token Binding ID,
	the client may need to establish a TLS connection between itself and the protected resource
	prior to making the request to the authorization server so that the Provided Token Binding ID
	for the TLS connection to the protected resource can be obtained.
	How the client retrieves this Token Binding ID
	from the underlying Token Binding API is implementation and operating system specific.
	An alternative, if supported, is for the client to generate a Token Binding key
	to use for the protected resource, use the Token Binding ID for that key,
	and then later use that key when the TLS connection to the protected resource is established.
      </t>

      <section anchor="AccessTokenFromAuthzEndpoint"
               title="Access Tokens Issued from the Authorization Endpoint">
	<t>
	  For access tokens returned directly from the authorization endpoint,
	  such as with the implicit grant defined in Section 4.2 of
	  <xref target="RFC6749">OAuth 2.0</xref>, the Token Binding ID of
	  the client's TLS channel to the protected resource is sent with
	  the authorization request as the Referred Token Binding ID in the
	  <spanx style="verb">Sec-Token-Binding</spanx> header,
	  and is used to Token Bind the access token.
	</t>
	<t>
	  Upon receiving the Referred Token Binding ID
	  in an authorization request,
	  the authorization server associates (Token Binds) the ID with the access token
	  in a way that can be accessed by the protected resource.
	  Such methods include embedding the Referred Token Binding ID
	  (or a cryptographic hash of it) in the issued access token itself,
    possibly using the syntax described in <xref target="Representation"/>,
    or through token introspection as described in <xref target="introspect"/>.
	  The method for associating the referred token binding ID with the access token
	  is determined by the authorization server and the protected resource,
	  and is beyond the scope for this specification.
	</t>

        <section anchor="AccessTokenFromAuthzEndpointEx"
                 title="Example Access Token Issued from the Authorization Endpoint">
  <t>
    This section provides an example of what the interactions around a
    Token Bound access token issued from the authorization endpoint might look
    like, along with some details of the involved processing.
    Extra line breaks in all examples are for display purposes only.
  </t>
  <t>
    The client directs the user-agent to make the following HTTP request to the
    authorization endpoint. It is a typical authorization request that,
    because Token Binding was negotiated on the underlying TLS connection and the
    user-agent was signaled to reveal the Referred Token Binding, also includes
    the <spanx style="verb">Sec-Token-Binding</spanx> header with a Token Binding Message
    that contains both a Provided and Referred Token Binding.  The base64url-encoded EKM
    from the TLS connection over which the request was made is
    <spanx style="verb">jI5UAyjs5XCPISUGQIwgcSrOiVIWq4fhLVIFTQ4nLxc</spanx>.
  </t>

<figure title="Authorization Request" anchor="AuthzRequestEx">
  <artwork><![CDATA[
 GET /as/authorization.oauth2?response_type=token
   &client_id=example-client-id&state=rM8pZxG1c3gKy6rEbsD8s
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb HTTP/1.1
 Host: server.example.com
 Sec-Token-Binding: ARIAAgBBQIEE8mSMtDy2dj9EEBdXaQT9W3Rq1NS-jW8ebPoF
   6FyL0jIfATVE55zlircgOTZmEg1xeIrC3DsGegwjs4bhw14AQGKDlAXFFMyQkZegC
   wlbTlqX3F9HTt-lJxFU_pi16ezka7qVRCpSF0BQLfSqlsxMbYfSSCJX1BDtrIL7PX
   j__fUAAAECAEFA1BNUnP3te5WrwlEwiejEz0OpesmC5PElWc7kZ5nlLSqQTj1ciIp
   5vQ30LLUCyM_a2BYTUPKtd5EdS-PalT4t6ABADgeizRa5NkTMuX4zOdC-R4cLNWVV
   O8lLu2Psko-UJLR_XAH4Q0H7-m0_nQR1zBN78nYMKPvHsz8L3zWKRVyXEgAA
]]></artwork>
</figure>

    <t>
      The authorization
      server issues an access token and delivers it to the client
      by redirecting the user-agent with the following HTTP response:
    </t>

<figure title="Authorization Response" anchor="AuthzRespEx">
  <artwork><![CDATA[
 HTTP/1.1 302 Found
 Location: https://client.example.org/cb#state=rM8pZxG1c3gKy6rEbsD8s
   &expires_in=3600&token_type=Bearer
   &access_token=eyJhbGciOiJFUzI[...omitted for brevity...]8xy5W5sQ
]]></artwork>
</figure>


    <t>
      The access token is bound to the Referred Token Binding ID from
      the authorization request, which when
      represented as a JWT, as described in <xref target="Representation"/>,
      contains the SHA-256 hash of the
      Token Binding ID as the value of the <spanx style="verb">tbh</spanx> (token binding hash)
      member of the <spanx style="verb">cnf</spanx> (confirmation) claim. The confirmation claim
      portion of the JWT Claims Set is shown in the following figure.
    </t>

<figure title="Confirmation Claim" anchor="ATFromAuthzEndpoint">
  <artwork><![CDATA[
 {
   ...other claims omitted for brevity...
   "cnf":{
      "tbh": "vowQESa_MgbGJwIXaFm_BTN2QDPwh8PhuBm-EtUAqxc"
   }
 }
]]></artwork>
</figure>

        </section>
      </section>

      <section anchor="AccessTokenFromTokenEndpoint"
               title="Access Tokens Issued from the Token Endpoint">
	<t>
	  For access tokens returned from the token endpoint,
	  the Token Binding ID of the client's TLS channel to the protected resource
	  is sent as the Referred Token Binding ID in the <spanx style="verb">Sec-Token-Binding</spanx> header,
	  and is used to Token Bind the access token.
	  This applies to all the grant types from OAuth 2.0 <xref target="RFC6749"/> using the token endpoint,
	  including, but not limited to the refresh and authorization code token requests,
	  as well as some extension grants, such as JWT assertion authorization grants <xref target="RFC7523"/>.
	</t>
	<t>
	  Upon receiving the Referred Token Binding ID
	  in a token request,
	  the authorization server associates (Token Binds) the ID with the access token
	  in a way that can be accessed by the protected resource.
	  Such methods include embedding the Referred Token Binding ID
	  (or a cryptographic hash of it) in the issued access token itself,
	  possibly using the syntax described in <xref target="Representation"/>,
	  or through token introspection as described in <xref target="introspect"/>.
	  The method for associating the referred token binding ID with the access token
	  is determined by the authorization server and the protected resource,
	  and is beyond the scope for this specification.
	</t>
	<t>
	  Note that if the request results in a new refresh token being generated,
	  it can be Token bound using the Provided Token Binding ID,
	  per <xref target="RefreshTokenBinding"/>.
	</t>

        <section anchor="AccessTokenFromTokenEndpointEx"
                 title="Example Access Token Issued from the Token Endpoint">

    <t>
      This section provides an example of what the interactions around a
      Token Bound access token issued from the token endpoint might look
      like, along with some details of the involved processing.
      Extra line breaks in all examples are for display purposes only.
    </t>
    <t>
      The client makes an access token request to the token endpoint
      and includes the <spanx style="verb">Sec-Token-Binding</spanx> header
      with a Token Binding Message
      that contains both Provided and Referred Token Binding IDs.
      The Provided Token Binding ID is used to validate the token binding of the refresh token
      in the request (and to Token Bind a new refresh token, if one is issued),
      and the Referred Token Binding ID is used to Token Bind the access token that is generated.
      The base64url-encoded EKM
      from the TLS connection over which the access token request was made is
      <spanx style="verb">4jTc5e1QpocqPTZ5l6jsb6pRP18IFKdwwPvasYjn1-E</spanx>.
    </t>
          <figure title="Access Token Request" anchor="TokenEndpointRequestEx">
            <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: ARIAAgBBQJFXJir2w4gbJ7grBx9uTYWIrs9V50-PW4ZijegQ
   0LUM-_bGnGT6DizxUK-m5n3dQUIkeH7ybn6wb1C5dGyV_IAAQDDFToFrHt41Zppq7
   u_SEMF_E-KimAB-HewWl2MvZzAQ9QKoWiJCLFiCkjgtr1RrA2-jaJvoB8o51DTGXQ
   ydWYkAAAECAEFAuC1GlYU83rqTGHEau1oqvNwy0fDsdXzIyT_4x1FcldsMxjFkJac
   IBJFGuYcccvnCak_duFi3QKFENuwxql-H9ABAMcU7IjJOUA4IyE6YoEcfz9BMPQqw
   M5M6hw4RZNQd58fsTCCslQE_NmNCl9JXy4NkdkEZBxqvZGPr0y8QZ_bmAwAA

 refresh_token=gZR_ZI8EAhLgWR-gWxBimbgZRZi_8EAhLgWRgWxBimbf
  &grant_type=refresh_token&client_id=example-client-id
]]></artwork>
          </figure>

    <t>
      The authorization
      server issues an access token bound to the
      Referred Token Binding ID and delivers it in a response the client.
    </t>

          <figure title="Response" anchor="TokenEndpointRespEx">
            <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtp[...omitted...]1cs29j5c3",
  "token_type":"Bearer",
  "expires_in":3600
 }
]]></artwork>
          </figure>


  <t>
    The access token is bound to the Referred Token Binding ID of the
    access token request, which when
    represented as a JWT, as described in <xref target="Representation"/>,
    contains the SHA-256 hash of the
    Token Binding ID as the value of the <spanx style="verb">tbh</spanx> (token binding hash)
    member of the <spanx style="verb">cnf</spanx> (confirmation) claim. The confirmation claim portion
    of the JWT Claims Set of the access token is shown in the following figure.
  </t>

          <figure title="Confirmation Claim" anchor="ATFromTokenEndpoint">
            <artwork><![CDATA[
 {
   ...other claims omitted for brevity...
   "cnf":{
      "tbh": "7NRBu9iDdJlYCTOqyeYuLxXv0blEA-yTpmGIrAwKAws"
   }
 }
]]></artwork>
          </figure>

        </section>

      </section>

      <section anchor="Resource" title="Protected Resource Token Binding Validation">
	<t>
	  Upon receiving a token bound access token, the protected resource validates the binding
	  by comparing the Provided Token Binding ID
	  to the Token Binding ID for the access token.
	  Alternatively, cryptographic hashes of these Token Binding ID values can be compared.
	  If the values do not match, the resource access attempt MUST be rejected with an error.
	</t>
	<section anchor="ResourceExample" title="Example Protected Resource Request">
  <t>
    For example, a protected resource request using the access token from
    <xref target="AccessTokenFromTokenEndpointEx"/> would look something like the following.
    The base64url-encoded EKM
    from the TLS connection over which the request was made is
    <spanx style="verb">7LsNP3BT1aHHdXdk6meEWjtSkiPVLb7YS6iHp-JXmuE</spanx>.
    The protected resource validates the binding
    by comparing the Provided Token Binding ID from the
    <spanx style="verb">Sec-Token-Binding</spanx> header to the token binding hash
    confirmation of the access token. Extra line breaks in the example are for
    display purposes only.
  </t>
        <figure title="Protected Resource Request" anchor="ProtectedResourceRequestEc">
          <artwork><![CDATA[
 GET /api/stuff HTTP/1.1
 Host: resource.example.org
 Authorization: Bearer eyJhbGciOiJFUzI1NiIsI[...omitted...]1cs29j5c3
 Sec-Token-Binding: AIkAAgBBQLgtRpWFPN66kxhxGrtaKrzcMtHw7HV8yMk_-MdR
   XJXbDMYxZCWnCASRRrmHHHL5wmpP3bhYt0ChRDbsMapfh_QAQN1He3Ftj4Wa_S_fz
   ZVns4saLfj6aBoMSQW6rLs19IIvHze7LrGjKyCfPTKXjajebxp-TLPFZCc0JTqTY5
   _0MBAAAA
]]></artwork>
        </figure>
	</section>

      </section>

      <section anchor="Representation" title="Representing Token Binding in JWT Access Tokens">
	<t>
	  If the access token is represented as a JWT,
	  the token binding information SHOULD be represented in the same way
	  that it is in token bound OpenID Connect ID Tokens
	  <xref target="OpenID.TokenBinding"/>.
	  That specification defines the new JWT Confirmation Method
	  <xref target="RFC7800">RFC 7800</xref>
	  member <spanx style="verb">tbh</spanx> (token binding hash) 
	  to represent the SHA-256 hash of a Token Binding ID
	  in an ID Token.
	  The value of the <spanx style="verb">tbh</spanx> member is the
	  base64url encoding of the SHA-256 hash of the Token Binding ID.
	</t>
	<t>
	  The following example demonstrates the JWT Claims Set of an access token
	  containing the base64url encoding of the SHA-256 hash of a Token Binding ID
	  as the value of the <spanx style="verb">tbh</spanx> (token binding hash)
	  element in the <spanx style="verb">cnf</spanx> (confirmation) claim:
	</t>
	<figure title="JWT with Token Binding Hash Confirmation Claim" anchor="TBHJWT">
	  <artwork><![CDATA[
  {
   "iss": "https://server.example.com",
   "aud": "https://resource.example.org",
   "sub": "brian@example.com"
   "iat": 1467324320,
   "exp": 1467324920,
   "cnf":{
     "tbh": "7NRBu9iDdJlYCTOqyeYuLxXv0blEA-yTpmGIrAwKAws"
    }
  }
]]></artwork>
	</figure>

      </section>

      <section anchor="introspect" title="Representing Token Binding in Introspection Responses">
    <t>
      <xref target="RFC7662">OAuth 2.0 Token Introspection</xref> defines a
      method for a protected resource to query
      an authorization server about the active state of an
      access token as well as to determine meta-information about the token.
    </t>
    <t>
      For a token bound access token, the hash of the
      Token Binding ID to which the token is bound
      is conveyed to the protected resource as meta-information
      in a token introspection response. The hash is conveyed using same structure as the
      token binding hash confirmation method, described in
      <xref target="Representation"/>, as a top-level member of the introspection response JSON.
      The protected resource compares
      that token binding hash to a hash of the provided Token Binding ID
      and rejects the request, if they do not match.
    </t>
    <t>
      The following is an example of an introspection response for an active token bound access token with
      a <spanx style="verb">tbh</spanx> token binding hash confirmation method.
    </t>

        <figure anchor="tbh7662" title="Example Introspection Response for a Token Bound Access Token">
          <artwork><![CDATA[

  HTTP/1.1 200 OK
  Content-Type: application/json

  {
    "active": true,
    "iss": "https://server.example.com",
    "aud": "https://resource.example.org",
    "sub": "brian@example.com"
    "iat": 1467324320,
    "exp": 1467324920,
    "cnf":{
      "tbh": "7NRBu9iDdJlYCTOqyeYuLxXv0blEA-yTpmGIrAwKAws"
    }
  }]]>
          </artwork>
        </figure>
      </section>

    </section>

    <section anchor="Metadata" title="Token Binding Metadata">
      <section anchor="ClientMetadata" title="Token Binding Client Metadata">
        <t>
          Clients supporting Token Binding that also support
          the <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref>
          use these metadata values to declare their support for Token Binding
          of access tokens and refresh tokens:
        </t>
        <t>
          <list style="hanging">
            <t hangText="client_access_token_token_binding_supported">
              <vspace/>
              OPTIONAL.
              Boolean value specifying whether the client supports Token Binding of access tokens.
              If omitted, the default value is <spanx style="verb">false</spanx>.
            </t>
            <t hangText="client_refresh_token_token_binding_supported">
              <vspace/>
              OPTIONAL.
              Boolean value specifying whether the client supports Token Binding of refresh tokens.
              If omitted, the default value is <spanx style="verb">false</spanx>.
              Authorization servers MUST NOT Token Bind refresh tokens issued
              to a client that does not support Token Binding
              of refresh tokens, but MAY reject requests completely from such clients if 
              token binding is required by authorization server policy by returning
              an OAuth error response.
            </t>
          </list>
        </t>
      </section>

      <section anchor="ASMetadata" title="Token Binding Authorization Server Metadata">
        <t>
          Authorization servers supporting Token Binding that also support
          <xref target="OAuth.AuthorizationMetadata">OAuth 2.0 Authorization Server Metadata</xref>
          use these metadata values to declare their support for Token Binding
          of access tokens and refresh tokens:
        </t>
        <t>
          <list style="hanging">
            <t hangText="as_access_token_token_binding_supported">
              <vspace/>
              OPTIONAL.
              Boolean value specifying whether the authorization server supports Token Binding of access tokens.
              If omitted, the default value is <spanx style="verb">false</spanx>.
            </t>
            <t hangText="as_refresh_token_token_binding_supported">
              <vspace/>
              OPTIONAL.
              Boolean value specifying whether the authorization server supports Token Binding of refresh tokens.
              If omitted, the default value is <spanx style="verb">false</spanx>.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section anchor="AuthzCodeTokenBinding" title="Token Binding for Authorization Codes">
    <t>
      There are two variations for Token Binding of an authorization code.
      One is appropriate for native application clients and the other for web server clients.
      The nature of where the various components reside for the different client types
      demands different methods of Token Binding the authorization code so that it is bound to a Token Binding
      key on the end user's device. This ensures that a lost or stolen authorization code cannot be successfully
      utilized from a different device.
      For native application clients, the code is bound to a Token Binding key pair
      that the native client itself possesses.
      For web server clients, the code is bound to a Token Binding key pair on the end user's
      browser.
      Both variations utilize the extensible framework of
      <xref target="RFC7636">Proof Key for Code Exchange (PKCE)</xref>, which enables the
      client to show possession of a certain key when exchanging the authorization code for tokens.
      The following subsections individually describe each of the two PKCE methods respectively.
    </t>

      <section anchor="NativeAppClients" title="Native Application Clients">
        <t>
          This section describes a PKCE method suitable for native application clients
          that cryptographically binds the authorization code to a Token Binding key pair on the client,
          which the client proves possession of on the TLS connection during the access token request
          containing the authorization code.
          The authorization code is bound to the Token Binding ID that the native application
          client uses to resolve the authorization code at the token endpoint. This binding ensures that
          the client that made the authorization request is the same client that
          is presenting the authorization code.
        </t>
        <section anchor="NativeCodeChallenge" title="Code Challenge">
          <t>
            As defined in <xref target="RFC7636">Proof Key for Code Exchange</xref>,
            the client sends the code challenge as part of the OAuth 2.0
            authorization request with the two additional parameters:
            <spanx style="verb">code_challenge</spanx> and <spanx style="verb">code_challenge_method</spanx>.
          </t>
          <t>
            For this Token Binding method of PKCE, <spanx style='verb'>TB-S256</spanx>
            is used as the value of the <spanx style="verb">code_challenge_method</spanx> parameter.
          </t>
          <t>
            The value of the <spanx style="verb">code_challenge</spanx> parameter is the base64url encoding
            (per Section 5 of <xref target="RFC4648"/> with all trailing padding ('=')
            characters omitted and without the inclusion of any line breaks or whitespace)
            of the SHA-256 hash of the Provided Token Binding ID
            that the client will use when calling the authorization server's
            token endpoint. Note that, prior to making the authorization request, the client may need to
            establish a TLS connection between itself and the authorization server's token endpoint in order to establish
            the appropriate Token Binding ID.
          </t>
          <t>
            When the authorization server issues the authorization code in the authorization
            response, it associates the code challenge and method values
            with the authorization code so they can be verified later when the authorization code is
            presented in the access token request.
          </t>

	  <section anchor="NativeCodeChallengeExample" title="Example Code Challenge">

          <t>
            For example, a native application client sends an authorization request by
            sending the user's browser to the authorization endpoint. The resulting HTTP
            request looks something like the following (with extra line breaks for display purposes only).
          </t>

          <figure title="Authorization Request with PKCE Challenge" anchor="NativeCodeChallengeEx">
            <artwork><![CDATA[
 GET /as/authorization.oauth2?response_type=code
   &client_id=example-native-client-id&state=oUC2jyYtzRCrMyWrVnGj
   &code_challenge=rBlgOyMY4teiuJMDgOwkrpsAjPyI07D2WsEM-dnq6eE
   &code_challenge_method=TB-S256 HTTP/1.1
 Host: server.example.com
]]></artwork>
          </figure>
	  </section>

        </section>

        <section anchor="NativeCodeVerifier" title="Code Verifier">
          <t>
            Upon receipt of the authorization code, the client sends the access
            token request to the token endpoint. The <xref target="I-D.ietf-tokbind-protocol">Token Binding Protocol</xref>
            is negotiated on the TLS connection between the client and the authorization server and the
            <spanx style="verb">Sec-Token-Binding</spanx> header, as defined in
            <xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>,
            is included in the access token request. The authorization server extracts the
            Provided Token Binding ID from the header value, hashes it with SHA-256, and compares
            it to the <spanx style="verb">code_challenge</spanx> value previously associated with the authorization code.
            If the values match, the token endpoint continues processing
            as normal (as defined by <xref target="RFC6749">OAuth 2.0</xref>).  If the values do not
            match, an error response indicating "invalid_grant" MUST be returned.
          </t>
          <t>
            The <spanx style="verb">Sec-Token-Binding</spanx> header contains sufficient information for verification of the
            authorization code and its association to the original authorization request. However, <xref target="RFC7636">PKCE</xref>
            requires that a <spanx style="verb">code_verifier</spanx> parameter be
            sent with the access token request, so the static value <spanx style="verb">provided_tb</spanx> is used to meet that
            requirement and indicate that the Provided Token Binding ID is used for the verification.
          </t>

	  <section anchor="NativeCodeVerifierExample" title="Example Code Verifier">
          <t>
            An example access token request, correlating to the authorization request in the previous example,
            to the token endpoint over a TLS connection for which
            Token Binding has been negotiated would look like the following (with extra line breaks for display purposes only).
            The base64url-encoded EKM
            from the TLS connection over which the request was made is
            <spanx style="verb">pNVKtPuQFvylNYn000QowWrQKoeMkeX9H32hVuU71Bs</spanx>.
          </t>

          <figure title="Token Request with PKCE Verifier" anchor="NativeCodeVerifierEx">
<artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: AIkAAgBBQEOO9GRFP-LM0hoWw6-2i318BsuuUum5AL8bt1sz
   lr1EFfp5DMXMNW3O8WjcIXr2DKJnI4xnuGsE6GywQd9RbD0AQJDb3xyo9PBxj8M6Y
   jLt-6OaxgDkyoBoTkyrnNbLc8tJQ0JtXomKzBbj5qPtHDduXc6xz_lzvNpxSPxi42
   8m7wkAAA

 grant_type=authorization_code&code=mJAReTWKX7zI3oHUNd4o3PeNqNqxKGp6
   &code_verifier=provided_tb&client_id=example-native-client-id
]]></artwork>
          </figure>
	  </section>
        </section>
      </section>


      <section anchor="WebServerClients" title="Web Server Clients">
        <t>
          This section describes a PKCE method suitable for web server clients,
          which cryptographically binds the authorization code to a Token Binding
          key pair on the browser.
          The authorization code is bound to the Token Binding ID that the browser
          uses to deliver the authorization code to a web server client, which is sent to the
          authorization server as the Referred Token Binding ID during the authorization request.
          The web server client
          conveys the Token Binding ID to the authorization server when making
          the access token request containing the authorization code.
          This binding ensures that the authorization code cannot successfully be played or replayed to the
          web server client from a different browser than the one that made the authorization request.
        </t>
        <section anchor="WebCodeChallenge" title="Code Challenge">
          <t>
            As defined in <xref target="RFC7636">Proof Key for Code Exchange</xref>,
            the client sends the code challenge as part of the OAuth 2.0
            Authorization Request with the two additional parameters:
            <spanx style="verb">code_challenge</spanx> and <spanx style="verb">code_challenge_method</spanx>.
          </t>
          <t>
            The client must send the authorization request through the browser such that
            the Token Binding ID established between the browser and itself is revealed
            to the authorization server's authorization endpoint as the Referred Token Binding ID.
            Typically, this is done with an HTTP redirection response and the
            <spanx style="verb">Include-Referred-Token-Binding-ID</spanx> header, as defined in
            <xref target="I-D.ietf-tokbind-https">Section 5.3 of Token Binding over HTTP</xref>.
          </t>
          <t>
            For this Token Binding method of PKCE, <spanx style='verb'>referred_tb</spanx>
            is used for the value of the <spanx style="verb">code_challenge_method</spanx> parameter.
          </t>
          <t>
            The value of the <spanx style="verb">code_challenge</spanx> parameter is
            <spanx style='verb'>referred_tb</spanx>. The static value for the required PKCE
            parameter indicates that the authorization code is to be bound to the
            Referred Token Binding ID from the Token Binding Message sent in the
            <spanx style="verb">Sec-Token-Binding</spanx> header of the authorization request.
          </t>
          <t>
            When the authorization server issues the authorization code in the authorization
            response, it associates the Token Binding ID (or hash thereof) and code challenge method
            with the authorization code so they can be verified later when the authorization code is
            presented in the access token request.
          </t>

	  <section anchor="WebCodeChallengeExample" title="Example Code Challenge">
          <t>
            For example, the web server client sends the authorization request by
            redirecting the browser to the authorization endpoint. That HTTP redirection
            response looks like the following (with extra line breaks for display purposes only).
          </t>

          <figure title="Redirect the Browser" anchor="WebCodeChallenge302Ex">
            <artwork><![CDATA[
 HTTP/1.1 302 Found
 Location: https://server.example.com?response_type=code
   &client_id=example-web-client-id&state=P4FUFqYzs1ij3ffsYCP34d3
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb
   &code_challenge=referred_tb&code_challenge_method=referred_tb
 Include-Referred-Token-Binding-ID: true
]]></artwork>
          </figure>

          <t>
            The redirect includes the <spanx style="verb">Include-Referred-Token-Binding-ID</spanx>
            response header field that signals to the user-agent that it
            should reveal, to the authorization server, the Token Binding ID used
            on the connection to the web server client. The resulting HTTP request to the
            authorization server looks something like the following
            (with extra line breaks for display purposes only). The base64url-encoded EKM
            from the TLS connection over which the request was made is
            <spanx style="verb">7gOdRzMhPeO-1YwZGmnVHyReN5vd2CxcsRBN69Ue4cI</spanx>.

          </t>


          <figure title="Authorization Request" anchor="WebCodeChallengeEx">
            <artwork><![CDATA[
 GET /as/authorization.oauth2?response_type=code
   &client_id=example-web-client-id&state=dryo8YFpWacbUPjhBf4Nvt51
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb
   &code_challenge=referred_tb
   &code_challenge_method=referred_tb HTTP/1.1
 Host: server.example.com
 Sec-Token-Binding: ARIAAgBBQB-XOPf5ePlf7ikATiAFEGOS503lPmRfkyymzdWw
   HCxl0njjxC3D0E_OVfBNqrIQxzIfkF7tWby2ZfyaE6XpwTsAQBYqhFX78vMOgDX_F
   d_b2dlHyHlMmkIz8iMVBY_reM98OUaJFz5IB7PG9nZ11j58LoG5QhmQoI9NXYktKZ
   RXxrYAAAECAEFAdUFTnfQADkn1uDbQnvJEk6oQs38L92gv-KO-qlYadLoDIKe2h53
   hSiKwIP98iRj_unedkNkAMyg9e2mY4Gp7WwBAeDUOwaSXNz1e6gKohwN4SAZ5eNyx
   45Mh8VI4woL1BipLoqrJRoK6dxFkWgHRMuBROcLGUj5PiOoxybQH_Tom3gAA
]]></artwork>
          </figure>
	  </section>


        </section>

        <section anchor="WebCodeVerifier" title="Code Verifier">

          <t>
            The web server client receives the authorization code from the browser and
            extracts the Provided Token Binding ID from the
            <spanx style="verb">Sec-Token-Binding</spanx> header of the request.
            The client sends the base64url-encoded
            (per Section 5 of <xref target="RFC4648"/> with all trailing padding ('=')
            characters omitted and without the inclusion of any line breaks or whitespace)
            Provided Token Binding ID as the value of the
            <spanx style="verb">code_verifier</spanx> parameter in the access token request
            to the authorization server's token endpoint.


            The authorization server compares the value of the
            <spanx style="verb">code_verifier</spanx> parameter
            to the Token Binding ID value previously associated with the authorization code.
            If the values match, the token endpoint continues processing
            as normal (as defined by <xref target="RFC6749">OAuth 2.0</xref>).  If the values do not
            match, an error response indicating "invalid_grant" MUST be returned.
          </t>

	  <section anchor="WebCodeVerifierExample" title="Example Code Verifier">
          <t>
            Continuing the example from the previous section, the authorization server
            sends the code to the web server client by redirecting the browser to
            the client's <spanx style="verb">redirect_uri</spanx>, which results in the browser
            making a request like the following (with extra line breaks for display purposes only)
            to the web server client over a TLS channel for which Token Binding has been established.
            The base64url-encoded EKM
            from the TLS connection over which the request was made is
            <spanx style="verb">EzW60vyINbsb_tajt8ij3tV6cwy2KH-i8BdEMYXcNn0</spanx>.
          </t>
          <figure title="Authorization Response to Web Server Client" anchor="WebCodeVerifierRespEx">
<artwork><![CDATA[
 GET /cb?state=dryo8YFpWacbUPjhBf4Nvt51&code=jwD3oOa5cQvvLc81bwc4CMw
 Host: client.example.org
 Sec-Token-Binding: AIkAAgBBQHVBU530AA5J9bg20J7yRJOqELN_C_doL_ijvqpW
   GnS6AyCntoed4UoisCD_fIkY_7p3nZDZADMoPXtpmOBqe1sAQEwgC9Zpg7QFCDBib
   6GlZki3MhH32KNfLefLJc1vR1xE8l7OMfPLZHP2Woxh6rEtmgBcAABubEbTz7muNl
   Ln8uoAAA
]]></artwork>
          </figure>

          <t>
            The web server client takes the Provided Token Binding ID from the
            above request from the browser and sends it, base64url encoded, to the
            authorization server in the <spanx style="verb">code_verifier</spanx>
            parameter of the authorization code grant type request.
            Extra line breaks in the example request are for display purposes only.
          </t>
          <figure title="Exchange Authorization Code" anchor="WebCodeVerifierTokenReqEx">
<artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Authorization: Basic b3JnLmV4YW1wbGUuY2xpZW50OmlldGY5OGNoaWNhZ28=

 grant_type=authorization_code&code=jwD3oOa5cQvvLc81bwc4CMw
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb
   &client_id=example-web-client-id
   &code_verifier=AgBBQHVBU530AA5J9bg20J7yRJOqELN_C_doL_ijv
   qpWGnS6AyCntoed4UoisCD_fIkY_7p3nZDZADMoPXtpmOBqe1s
]]></artwork>
          </figure>
	  </section>

        </section>
      </section>

    </section>

    <section anchor="tb7523" title="Token Binding JWT Authorization Grants and Client Authentication">
      <t>
        The <xref target="RFC7523">JWT Profile for OAuth 2.0 Client Authentication and
        Authorization Grants</xref> defines the use of bearer JWTs
        as a means for requesting an OAuth 2.0 access token as well as
        for client authentication.
        This section describes extensions to that specification enabling the application of Token
        Binding to JWT client authentication and JWT authorization grants.
      </t>
      <section anchor="tb7523processing" title="JWT Format and Processing Requirements">
        <t>
          In addition the requirements set forth in <xref target="RFC7523">Section 3 of RFC 7523</xref>,
          the following criteria must also be met for token bound JWTs used as authorization
          grants or for client authentication.
        </t>
        <t>
          <list style='symbols'>
            <t>
              The JWT MUST contain a <spanx style="verb">cnf</spanx>
              (confirmation) claim with a <spanx style="verb">tbh</spanx>
              (token binding hash) member identifying the Token Binding ID
              of the Provided Token Binding used by the client on the TLS
              connection to the authorization server.
              The authorization server MUST reject any JWT that has a token binding hash
              confirmation that does not match the corresponding hash of the
              Provided Token Binding ID from the
              <spanx style="verb">Sec-Token-Binding</spanx> header of the request.
            </t>
          </list>
        </t>
      </section>
      <section anchor="tb7523authn" title="Token Bound JWTs for Client Authentication">
        <t>
          To use a token bound JWT for client authentication, the client uses
          the parameter values and encodings from
          <xref target="RFC7523">Section 2.2 of RFC 7523</xref> with one exception:
          the value of the <spanx style='verb'>client_assertion_type</spanx> is
            <spanx style='verb'>urn:ietf:params:oauth:client-assertion-type:jwt-token-bound</spanx>.
        </t>

        <t>
          The "OAuth Token Endpoint Authentication Methods" registry
          <xref target="IANA.OAuth.Parameters"/> contains values, each of which specify a
          method of authenticating a client to the authorization server.  The values are
          used to indicated supported and utilized client authentication methods
          in authorization server metadata, such as
          <xref target="OpenID.Discovery"/> and <xref target="OAuth.AuthorizationMetadata"/>,
          and in
          <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref>.
          The values <spanx style="verb">private_key_jwt</spanx> and <spanx style="verb">client_secret_jwt</spanx>
          are designated by <xref target="OpenID.Core">OpenID Connect</xref> as authentication method values for
          bearer JWT client authentication using asymmetric and symmetric <xref target="RFC7515">JWS</xref>
          algorithms respectively.
          For Token Bound JWT for client authentication, this specification
          defines and registers the following authentication method values.
        </t>
        <t>
          <list style="hanging">
            <t hangText="private_key_token_bound_jwt">
              <vspace/>
              Indicates that client authentication to the authorization server will occur with a Token Bound
              JWT, which is signed with a client's private key.
            </t>
            <t hangText="client_secret_token_bound_jwt">
              <vspace/>
              Indicates that client authentication to the authorization server will occur with a Token Bound
              JWT, which is integrity protected with a MAC using
              the octets of the UTF-8 representation of the client secret as the shared key.
            </t>
          </list>
        </t>

        <t>
          Note that just as with the <spanx style="verb">private_key_jwt</spanx> and
          <spanx style="verb">client_secret_jwt</spanx> authentication methods,
          the <spanx style="verb">token_endpoint_auth_signing_alg</spanx> client registration parameter
          may be used to indicate the JWS algorithm used for signing the client authentication JWT for
          the authentication methods defined above.
        </t>

      </section>
      <section anchor="tb7523grant" title="Token Bound JWTs for as Authorization Grants">
        <t>
          To use a token bound JWT for an authorization grant, the client uses
          the parameter values and encodings from
          <xref target="RFC7523">Section 2.1 of RFC 7523</xref> with one exception:
          the value of the <spanx style='verb'>grant_type</spanx> is
          <spanx style='verb'>urn:ietf:params:oauth:grant-type:jwt-token-bound</spanx>.
        </t>

      </section>
    </section>

    <section anchor="Security" title="Security Considerations">
      <section anchor="Phasing" title="Phasing in Token Binding">
        <t>
          Many OAuth implementations will be deployed in situations in which
          not all participants support Token Binding.
          Any of combination of the client, the authorization server, the protected resource,
          and the user agent may not yet support Token Binding,
          in which case it will not work end-to-end.
        </t>
        <t>
          It is a context-dependent deployment choice whether to allow
          interactions to proceed in which Token Binding is not supported
          or whether to treat the omission of Token Binding at any step as a fatal error.
          Particularly in dynamic deployment environments in which End Users have choices
          of clients, authorization servers, protected resources, and/or user agents,
          it is recommended that, for some reasonable period of time during which Token Binding
          technology is being adopted, authorizations using one or more components
          that do not implement Token Binding be allowed to successfully proceed.
          This enables different components to be upgraded to supporting Token Binding
          at different times, providing a smooth transition path for
          phasing in Token Binding.
          However, when Token Binding has been performed,
          any Token Binding key mismatches MUST be treated as fatal errors.
        </t>
        <t>
          In more controlled deployment environments where the participants in an authorization interaction
          are known or expected to support Token Binding and yet one or more of them does not use it,
          the authorization SHOULD be aborted with an error.
          For instance, an authorization server should reject a token request that does not include the
          <spanx style="verb">Sec-Token-Binding</spanx> header, if the request is from a client known to
          support Token Binding (via configuration or the
          <spanx style="verb">client_access_token_token_binding_supported</spanx>
          metadata parameter).
        </t>
      </section>
      <section title="Binding of Refresh Tokens">
        <t>
          <xref target="RFC6749">Section 6 of RFC 6749</xref> requires that
          a refresh token be bound to the client to which it was issued and that,
          if the client type is confidential or
          the client was issued client credentials (or assigned other
          authentication requirements), the client must authenticate with the
          authorization server when presenting the refresh token.
          As a result, for non-public clients, refresh tokens are indirectly bound
          to the client's credentials and cannot be used without the associated client
          authentication. Non-public clients then are afforded protections
          (equivalent to the strength of their authentication credentials) against
          unauthorized replay of refresh tokens and it is reasonable to not Token Bind
          refresh tokens for such clients while still Toking Binding the issued access tokens.
          Refresh tokens issued to public clients, however, do not have the benefit of such
          protections and authorization servers MAY elect to disallow public clients from
          registering or establishing configuration that would allow Token Bound access tokens
          but unbound refresh tokens.
        </t>
        <t>
          Some web-based confidential clients implemented as distributed nodes may
          be perfectly capable of implementing access token binding (if the access
          token remains on the node it was bound to, the token binding keys would
          be locally available for that node to prove possession), but may struggle with refresh token
          binding due to an inability to share token binding key material between nodes.
          As confidential clients already have credentials which are required to
          use the refresh token, and those credentials should only ever be sent over
          TLS server-to-server between the client and the Token Endpoint, there is still value in
          token binding access tokens without token binding refresh tokens.
          Authorization servers SHOULD consider supporting access token binding
          without refresh token binding for confidential web clients as there are
          still security benefits to do so.
        </t>
        <t>
          Clients MUST declare through dynamic (<xref target="ClientMetadata"/>) or static registration information
          what types of token bound tokens they support to enable the server to
          bind tokens accordingly, taking into account any phase-in policies.
          Authorization MAY reject requests from any client who does not support
          token binding (by returning an OAuth error response) per their own
          security policies.
        </t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section anchor="DynRegRegistration" title="OAuth Dynamic Client Registration Metadata Registration">
	<t>
	  This specification registers the following client metadata definitions
	  in the IANA "OAuth Dynamic Client Registration Metadata" registry
	  <xref target="IANA.OAuth.Parameters"/>
	  established by <xref target="RFC7591"/>:
	</t>

	<section anchor="DynRegContents" title="Registry Contents">
	  <t>
	    <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Client Metadata Name: <spanx style="verb">client_access_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Client Metadata Description:
		Boolean value specifying whether the client supports Token Binding of access tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ClientMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		Client Metadata Name: <spanx style="verb">client_refresh_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Client Metadata Description:
		Boolean value specifying whether the client supports Token Binding of refresh tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ClientMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section anchor="ASMetadataRegistration" title="OAuth Authorization Server Metadata Registration">
	<t>
	  This specification registers the following metadata definitions
	  in the IANA "OAuth Authorization Server Metadata" registry
	  <!-- <xref target="IANA.OAuth.Parameters"/> TBD Uncomment once registry has been established -->
	  established by <xref target="OAuth.AuthorizationMetadata"/>:
	</t>

	<section anchor="ASMetadataContents" title="Registry Contents">
	  <t>
	    <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Metadata Name: <spanx style="verb">as_access_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Metadata Description:
		Boolean value specifying whether the authorization server supports Token Binding of access tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ASMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		Metadata Name: <spanx style="verb">as_refresh_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Metadata Description:
		Boolean value specifying whether the authorization server supports Token Binding of refresh tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ASMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section anchor="PKCEMethodRegistration" title="PKCE Code Challenge Method Registration">
        <t>
          This specification requests registration of the following
          Code Challenge Method Parameter Names
          in the IANA "PKCE Code Challenge Methods" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC7636"/>.
        </t>

        <section anchor="PKCEMethodContents" title='Registry Contents'>

          <?rfc subcompact="yes"?>
          <t>
            <list style='symbols'>
              <t>Code Challenge Method Parameter Name: TB-S256</t>
              <t>Change controller: IESG</t>
              <t>Specification document(s): <xref target="NativeCodeChallenge"/> of [[ this specification ]]</t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>Code Challenge Method Parameter Name: referred_tb</t>
              <t>Change controller: IESG</t>
              <t>Specification document(s): <xref target="WebCodeChallenge"/> of [[ this specification ]]</t>
            </list>
          </t>
          <?rfc subcompact="no"?>

        </section>
      </section>

    </section>

    <section anchor="client_authIANA" title="Token Endpoint Authentication Method Registration">
      <t>
        This specification requests registration of the following values
        in the IANA "OAuth Token Endpoint Authentication Methods" registry
        <xref target="IANA.OAuth.Parameters"/> established by <xref target="RFC7591"/>.
      </t>
      <section title="Registry Contents">
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Token Endpoint Authentication Method Name: <spanx style="verb">client_secret_token_bound_jwt</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="tb7523"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Token Endpoint Authentication Method Name: <spanx style="verb">private_key_token_bound_jwt</spanx></t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): <xref target="tb7523"/> of [[ this specification ]]</t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>
    </section>

    <section title='Sub-Namespace Registrations' anchor="urnIANA">
      <t>
        This specification requests registration of the following values in the
        IANA "OAuth URI" registry
        <xref target="IANA.OAuth.Parameters"/>
        established in
        <xref target="RFC6755">An IETF URN Sub-Namespace for OAuth</xref>.
      </t>
      <section title="Registry Contents">
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>URN: urn:ietf:params:oauth:grant-type:jwt-token-bound</t>
            <t>Common Name: Token Bound JWT Grant Type for OAuth 2.0</t>
            <t>Change controller: IESG</t>
            <t>Specification Document:
              <xref target="tb7523"/>
              of [[ this specification ]]
            </t>
          </list>
          <?rfc subcompact="no"?>
        </t>
        <t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>URN: urn:ietf:params:oauth:client-assertion-type:jwt-token-bound</t>
            <t>Common Name: Token Bound JWT for OAuth 2.0 Client Authentication</t>
            <t>Change controller: IESG</t>
            <t>Specification Document:
              <xref target="tb7523"/>
              of [[ this specification ]]
            </t>
          </list>
          <?rfc subcompact="no"?>
        </t>
      </section>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648"?>  <!-- base64 -->
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7523"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7591"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7662"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7800"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174"?>

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tokbind-protocol-16.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tokbind-https-12.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tokbind-negotiation-10.xml' ?>



      <reference anchor="OpenID.TokenBinding" target="http://openid.net/specs/openid-connect-token-bound-authentication-1_0-02.html">
        <front>
          <title>OpenID Connect Token Bound Authentication 1.0</title>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization>Yubico</organization>
          </author>

	  <author fullname="Brian Campbell" initials="B." surname="Campbell">
	    <organization>Ping Identity</organization>
	  </author>

          <date day="26" month="October" year="2017"/>
        </front>
      </reference>

      <reference anchor="OAuth.AuthorizationMetadata" target="http://tools.ietf.org/html/draft-ietf-oauth-discovery-07">
        <front>
	  <title>OAuth 2.0 Authorization Server Metadata</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	      <uri>http://nat.sakimura.org/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	      <uri>http://www.thread-safe.com/</uri>
	    </address>
	  </author>

	  <date day="10" month="March" year="2017" />
        </front>
	<seriesInfo name="Internet-Draft" value="draft-ietf-oauth-discovery-07"/>
      </reference>

      <reference anchor="JWT" target="http://tools.ietf.org/html/rfc7519">
	<front>
	  <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <date month="May" year="2015" />
	</front>

	<seriesInfo name="RFC" value="7519"/>
	<seriesInfo name="DOI" value="10.17487/RFC7519"/>
      </reference>

      <reference anchor="SHS" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="March" year="2012" />
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4" />
        <format target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf" type="PDF" />
      </reference>

      <reference anchor="IANA.OAuth.Parameters" target="http://www.iana.org/assignments/oauth-parameters">
        <front>
          <title>OAuth Parameters</title>
          <author>
            <organization>IANA</organization>
          </author>
	  <date/>
        </front>
      </reference>

    </references>

    <references title="Informative References">
      <reference anchor="BCP212" target="https://www.rfc-editor.org/info/rfc8252">
        <front>
          <title>OAuth 2.0 for Native Apps</title>
          <author initials="W." surname="Denniss" fullname="W. Denniss">
            <organization/>
          </author>
          <author initials="J." surname="Bradley" fullname="J. Bradley">
            <organization/>
          </author>
          <date year="2017" month="October"/>
          <abstract>
            <t>OAuth 2.0 authorization requests from native apps should only be made through external user-agents, primarily the user's browser. This specification details the security and usability reasons why this is
              the case and how native apps and authorization servers can implement this best practice.
            </t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="212"/>
        <seriesInfo name="RFC" value="8252"/>
        <seriesInfo name="DOI" value="10.17487/RFC8252"/>
      </reference>

      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6755"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7515"?>

      <!-- http://openid.net/2017/02/03/bibxml-files-for-openid-specifications/ -->
      <?rfc include='http://openid.net/bibxml/reference.OpenID.Core.xml' ?>
      <?rfc include='http://openid.net/bibxml/reference.OpenID.Discovery.xml' ?>
    </references>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
	The authors would like to thank the following people for their contributions to the specification:
	Dirk Balfanz,
	Andrei Popov,
  Justin Richer,
	and
	Nat Sakimura.
      </t>
    </section>

    <!--<section anchor="TBD" title="Open Issues">-->
      <!--<t>-->
	      <!--<list style="symbols">-->

        <!--</list>-->
      <!--</t>-->
    <!--</section>-->

    <section anchor="History" title="Document History">
      <t>[[ to be removed by the RFC Editor before publication as an RFC ]]</t>
      <t>
    -06
    <list style="symbols">
      <t>Use the boilerplate from RFC 8174.</t>
      <t>Update reference for draft-ietf-tokbind-https to -12.</t>
    </list>
  </t>
  <t>
  -05
  <list style="symbols">
    <t>
      State that authorization servers should not token bind refresh tokens
      issued to a client that doesn't support bound refresh tokens,
      which can be indicated by the "client_refresh_token_token_binding_supported"
      client metadata parameter.
    </t>
    <t>
      Add Token Binding for JWT Authorization Grants and JWT Client Authentication.
    </t>
    <t>
      Adjust the language around aborting authorizations in Phasing in Token Binding to be somewhat more general and not only about downgrades.
    </t>
    <t>
      Remove reference to, and usage of, 'OAuth 2.0 Protected Resource Metadata', which is no longer a going concern.
    </t>
    <t>
      Moved "Token Binding Metadata" section before "Token Binding for Authorization Codes" to be closer
      to the "Token Binding for Access Tokens" and "Token Binding for Refresh Tokens", to which it is more
      closely related.
    </t>
    <t>
      Update references for draft-ietf-tokbind- negotiation(-10), protocol(-16), and https(-10),
      as well as draft-ietf-oauth-discovery(-07), and BCP212/RFC8252 OAuth 2.0 for Native Apps.
    </t>
  </list>
  </t>
  <t>
  -04
  <list style="symbols">
    <t>
      Define how to convey token binding information of an access token via
      RFC 7662 OAuth 2.0 Token Introspection (note that the Introspection Response
      Registration request for cnf/Confirmation is in
      https://tools.ietf.org/html/draft-ietf-oauth-mtls-02#section-4.3 which will
      likely be published and registered prior to this document).
    </t>
    <t>Minor editorial fixes.</t>
    <t>
      Added an open issue about needing to allow for web server clients to opt-out of having refresh tokens
      bound while still allowing for binding of access tokens
      (following from mention of the problem on slide 16 of the presentation
      from Chicago https://www.ietf.org/proceedings/98/slides/slides-98-oauth-sessb-token-binding-00.pdf).
    </t>
  </list>
      </t>
      <t>
  -03
  <list style="symbols">
    <t>Fix a few mistakes in and around the examples that were noticed preparing the slides for IETF 98 Chicago.</t>
  </list>
      </t>
      <t>
	-02
	<list style="symbols">
	  <t>Added a section on Token Binding for authorization codes with one variation for native clients and one for web server clients.</t>
	  <t>Updated language to reflect that the binding is to the token binding key pair and that proof-of-possession of that key is done on the TLS connection.</t>
	  <t>Added a bunch of examples.</t>
    <t>Added a few Open Issues so they are tracked in the document.</t>
	  <t>Updated the Token Binding and OAuth Metadata references.</t>
	  <t>Added William Denniss as an author.</t>
	</list>
      </t>

      <t>
	-01
        <list style="symbols">
	  <t>
	    Changed Token Binding for access tokens to use the Referred Token Binding ID,
	    now that the Implementation Considerations in the Token Binding HTTPS specification
	    make it clear that implementations will enable using the Referred Token Binding ID.
	  </t>
	  <t>
	    Defined Protected Resource Metadata value.
	  </t>
	  <t>
	    Changed to use the more specific term "protected resource" instead of "resource server".
	  </t>
	</list>
      </t>

      <t>
	-00
        <list style="symbols">
	  <t>
	    Created the initial working group version from draft-jones-oauth-token-binding-00.
	  </t>
	</list>
      </t>

    </section>

  </back>
</rfc>
