<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
"http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd">

<rfc category="std" docName="draft-ietf-oauth-token-binding-02" ipr="trust200902">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="5" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="yes" ?>
  <?rfc compact="yes" ?>
  <?rfc subcompact="no" ?>

  <front>
    <title abbrev="OAuth 2.0 Token Binding">OAuth 2.0 Token Binding</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
	<uri>http://self-issued.info/</uri>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Ping Identity">Ping Identity</organization>
      <address>
        <email>ve7jtb@ve7jtb.com</email>
	<uri>http://www.thread-safe.com/</uri>
      </address>
    </author>

    <author fullname="Brian Campbell" initials="B." surname="Campbell">
      <organization>Ping Identity</organization>
      <address>
	<email>brian.d.campbell@gmail.com</email>
	<uri>https://twitter.com/__b_c</uri>
      </address>
    </author>

    <date />

    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>

    <keyword>OAuth</keyword>
    <keyword>Token Binding</keyword>
    <keyword>Proof-of-Possession</keyword>
    <keyword>PoP</keyword>

    <abstract>
      <t>
	This specification enables OAuth 2.0 implementations to apply
	Token Binding to Access Tokens, Authorization Codes, and Refresh Tokens.
  This cryptographically binds these tokens to a client's Token Binding key
  pair, possession of which is proven on the TLS connections over which the
  tokens are intended to be used.
  This use of Token Binding protects these tokens
  from man-in-the-middle and token export and replay attacks.
       </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>
	This specification enables OAuth 2.0 <xref target="RFC6749"/> implementations to apply
	Token Binding (<xref target="I-D.ietf-tokbind-negotiation">
  TLS Extension for Token Binding Protocol Negotiation</xref>,
	<xref target="I-D.ietf-tokbind-protocol">The Token Binding Protocol Version 1.0</xref>
	and <xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>)
	to Access Tokens, Authorization Codes, and Refresh Tokens.
  This cryptographically binds these tokens to a client's Token Binding key
  pair, possession of which is proven on the TLS connections over which the
  tokens are intended to be used.
	This use of Token Binding protects these tokens
	from man-in-the-middle and token export and replay attacks.
      </t>

      <section anchor="rnc" title="Requirements Notation and Conventions">
	<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
	"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
	document are to be interpreted as described in <xref
	target="RFC2119">RFC 2119</xref>.</t>
      </section>

      <section anchor="Terminology" title="Terminology">
	<t>
	  This specification uses the terms "Access Token", "Authorization Code",
	  "Authorization Endpoint", "Authorization Server",
	  "Client", "Protected Resource", "Refresh Token",
	  and "Token Endpoint"
	  defined by <xref target="RFC6749">OAuth 2.0</xref>,
	  the terms "Claim" and "JSON Web Token (JWT)"
	  defined by <xref target="JWT">JSON Web Token (JWT)</xref>,
	  the term "User Agent" defined by <xref target="RFC7230">RFC 7230</xref>,
	  and
	  the terms "Provided", "Referred", "Token Binding" and "Token Binding ID"
	  defined by <xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
	</t>
      </section>
    </section>

    <section anchor="RefreshTokenBinding" title="Token Binding for Refresh Tokens">
      <t>
	Token Binding of refresh tokens is a straightforward first-party scenario,
	applying term "first-party" as used in
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
  It cryptographically binds the refresh token to the client's Token Binding key
  pair, possession of which is proven on the TLS connections between the
  client and the token endpoint.
	This case is straightforward because the refresh token is
	both retrieved by the client from the token endpoint
	and sent by the client to the token endpoint.
	Unlike the federated scenarios described in
	Section 4 (Federation Use Cases) of 
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>
	and the access token case described in the next section,
	only a single TLS connection is involved in the refresh token case.
      </t>
      <t>
	Token Binding a refresh token requires that the authorization server do two things.
	First, when refresh token is sent to the client, the authorization server needs to
	remember the Provided Token Binding ID
	and remember its association with the issued refresh token.
	Second, when a token request containing a refresh token is received at the token endpoint,
	the authorization server needs to verify that
	the Provided Token Binding ID for the request
	matches the remembered Token Binding ID associated with the refresh token.
	If the Token Binding IDs do not match,
	the authorization server should return an error in response to the request.
      </t>
      <t>
	How the authorization server remembers the association
	between the refresh token and the Token Binding ID
	is an implementation detail that beyond the scope of this specification.
	Some authorization servers will choose to store the Token Binding ID
	(or a cryptographic hash of it, such a SHA-256 hash <xref target="SHS"/>)
  in the refresh token itself, provided it is integrity-protected,
  thus reducing the amount of state to be kept by the server.
	Other authorization servers will add the Token Binding ID value (or a hash of it)
	to an internal data structure also containing other information about the refresh token,
	such as grant type information.
	These choices make no difference to the client, since the refresh token is opaque to it.
      </t>

    <section anchor="RefreshTokenBindingEx" title="Example Token Binding for Refresh Tokens">
    <t>
      This section provides an example of what the interactions around a
      Token Bound refresh token might look like, along with some details of
      the involved processing. Token Binding of refresh tokens is most useful
      for native application clients so the example has protocol elements typical
      of a native client flow.
      Extra line breaks in all examples are for
      display purposes only.
    </t>

    <t>
      A native application client makes the following access token request with an
      authorization code using a TLS connection where Token
      Binding has been negotiated. A PKCE <spanx style="verb">code_verifier</spanx> is
      included because use the of PKCE is considered best practice for native
      application clients <xref target="I-D.ietf-oauth-native-apps"/>.
      The base64url-encoded representation of
      the exported keying material (EKM) from that TLS connection is
      <spanx style="verb">p6ZuSwfl6pIe8es5KyeV76T4swZmQp0_awd27jHfrbo</spanx>, which is
      needed to validate the Token Binding Message.
    </t>

      <figure title="Initial Request with Code" anchor="RTEX1">
        <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: AIkAAgBBQGto7hHRR0Y5nkOWqc9KNfwW95dEFmSI_tCZ_Cbl
   7LWlt6Xjp3DbjiDJavGFiKP2HV_2JSE42VzmKOVVV8m7eqAAQOKiDK1Oi0z6v4X5B
   P7uc0pFestVZ42TTOdJmoHpji06Qq3jsCiCRSJx9ck2fWJYx8tLVXRZPATB3x6c24
   aY0ZEAAA

 grant_type=authorization_code&code=4bwcZesc7Xacc330ltc66Wxk8EAfP9j2
   &code_verifier=2x6_ylS390-8V7jaT9wj.8qP9nKmYCf.V-rD9O4r_1
   &client_id=example-native-client-id

]]></artwork>
      </figure>

    <t>
      A refresh token is issued in response to the prior request. Although it
      looks like a typical response to the client, the authorization server
      has bound the refresh token to the Provided Token Binding ID from the
      encoded Token Binding message in the <spanx style="verb">Sec-Token-Binding</spanx>
      header of the request. In this example,
      that binding is done by saving the Token Binding
      ID alongside other information about the refresh token in some server
      side persistent storage.
      The base64url-encoded representation of that Token Binding ID is
      <spanx style="verb">AgBBQGto7hHRR0Y5nkOWqc9KNfwW95dEFmSI_tCZ_Cbl7LWlt6Xjp3DbjiDJavGFiKP2HV_2JSE42VzmKOVVV8m7eqA</spanx>.

    </t>
    <figure title="Successful Response" anchor="RTEX2">
      <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"EdRs7qMrLb167Z9fV2dcwoLTC",
  "refresh_token":"ACClZEIQTjW9arT9GOJGGd7QNwqOMmUYfsJTiv8his4",
  "token_type":"Bearer",
  "expires_in":3600
 }

]]></artwork>
    </figure>

  <t>
    When the access token expires, the client requests a new one with
    a refresh request to the token endpoint. In this example, the request is made on a new
    TLS connection so the EKM (base64url-encoded:
    <spanx style="verb">va-84Ukw4Zqfd7uWOtFrAJda96WwgbdaPDX2knoOiAE</spanx>)
    and signature in the Token Binding Message are different than in the
    initial request.
  </t>

      <figure title="Refresh Request" anchor="RTEX3">
        <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: AIkAAgBBQGto7hHRR0Y5nkOWqc9KNfwW95dEFmSI_tCZ_Cbl
   7LWlt6Xjp3DbjiDJavGFiKP2HV_2JSE42VzmKOVVV8m7eqAAQCpGbaG_YRf27qOra
   L0UT4fsKKjL6PukuOT00qzamoAXxOq7m_id7O3mLpnb_sM7kwSxLi7iNHzzDgCAkP
   t3lHwAAA

refresh_token=ACClZEIQTjW9arT9GOJGGd7QNwqOMmUYfsJTiv8his4
  &grant_type=refresh_token&client_id=example-native-client-id

]]></artwork>
      </figure>

<t>
  However, because the Token Binding ID is long-lived and may span multiple TLS
  sessions and connections, it is the same as in the initial request. That
  Token Binding ID is what the refresh token is bound to, so the authorization
  server is able to verify it and issue a new access token.
</t>
      <figure title="Successful Response" anchor="RTEX4">
        <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"bwcESCwC4yOCQ8iPsgcn117k7",
  "token_type":"Bearer",
  "expires_in":3600
 }

]]></artwork>
      </figure>
    </section>
    </section>


    <section anchor="AccessTokenBinding" title="Token Binding for Access Tokens">
      <t>
  Token Binding for access tokens cryptographically binds the access token
  to the client's Token Binding key
  pair, possession of which is proven on the TLS connections between the
  client and the protected resource.
	Token Binding is applied to access tokens in a similar manner to that
	described in Section 4 (Federation Use Cases) of 
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
	It also builds upon the mechanisms for Token Binding of ID Tokens defined in
	<xref target="OpenID.TokenBinding">OpenID Connect Token Bound Authentication 1.0</xref>.
      </t>
      <t>
	In the OpenID Connect <xref target="OpenID.Core"/> use case,
	HTTP redirects are used to pass information
	between the identity provider and the relying party;
	this HTTP redirect makes the Token Binding ID of the relying party
	available to the identity provider as the Referred Token Binding ID,
	information about which is then added to the ID Token.
	No such redirect occurs between the authorization server and the protected resource
	in the access token case;
	therefore, information about the Token Binding ID for the TLS connection
	between the client and the protected resource needs to be explicitly
	communicated by the client to the authorization server to achieve Token Binding
	of the access token.
      </t>
      <t>
	This information is passed to the authorization server
	using the Referred Token Binding ID, just as in the ID Token case.
	The only difference is that the client needs to explicitly
	communicate the Token Binding ID of
	the TLS connection between the client and the protected resource
	to the Token Binding implementation so that it is sent as
	the Referred Token Binding ID in the request to the authorization server.
	This functionality provided by Token Binding implementations is described in
	Section 5 (Implementation Considerations) of
	<xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>.
      </t>
      <t>
	Note that to obtain this Token Binding ID,
	the client may need to establish a TLS connection between itself and the protected resource
	prior to making the request to the authorization server so that the Provided Token Binding ID
	for the TLS connection to the protected resource can be obtained.
	How the client retrieves this Token Binding ID
	from the underlying Token Binding API is implementation and operating system specific.
	An alternative, if supported, is for the client to generate a Token Binding key
	to use for the protected resource, use the Token Binding ID for that key,
	and then later use that key when the TLS connection to the protected resource is established.
      </t>

      <section anchor="AccessTokenFromAuthzEndpoint"
               title="Access Tokens Issued from the Authorization Endpoint">
	<t>
    For access tokens returned directly from the authorization endpoint,
    such as with the implicit grant defined in Section 4.2 of
    <xref target="RFC6749">OAuth 2.0</xref>, the Token Binding ID of
    client's TLS channel to the protected resource is sent with the authorization
    request as the Referred Token Binding ID in the
    <spanx style="verb">Sec-Token-Binding</spanx> header, and is used to bind
    the access token.
	</t>
  <t>
    Upon receiving the Referred Token Binding ID
    in an authorization request, the authorization server associates (binds) the
    ID with the access token in a way that can be retrieved by the protected
    resource. Such methods include embedding the Referred Token Binding ID (or a
    cryptographic hash of it) in the issued access token itself, or through
    token introspection <xref target="RFC7662"/>.  The exact method for
    associating the referred token binding ID is negotiated between the authorization 
    server and the protected resource, and is out of scope for this specification.
	</t>

        <section anchor="AccessTokenFromAuthzEndpointEx"
                 title="Example Access Token Issued from the Authorization Endpoint">
  <t>
    This section provides an example of what the interactions around a
    Token Bound access token issued from the authorization endpoint might look
    like, along with some details of the involved processing.
    Extra line breaks in all examples are for display purposes only.
  </t>
  <t>
    The client directs the user-agent to make the following HTTP request to the
    authorization endpoint. It is a typical authorization request that,
    because Token Binding was negotiated on the underlying TLS connection and the
    user-agent was signaled to reveal the Referred Token Binding, also includes
    the <spanx style="verb">Sec-Token-Binding</spanx> header with a Token Binding Message
    that contains both a Provided and Referred Token Binding.  The base64url-encoded EKM
    from the TLS connection over which the request was made is
    <spanx style="verb">jI5UAyjs5XCPISUGQIwgcSrOiVIWq4fhLVIFTQ4nLxc</spanx>.
  </t>

<figure title="Authorization Request" anchor="AuthzRequestEx">
  <artwork><![CDATA[
 GET /as/authorization.oauth2?response_type=token
   &client_id=example-client-id&state=rM8pZxG1c3gKy6rEbsD8s
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb HTTP/1.1
 Host: server.example.com
 Sec-Token-Binding: ARIAAgBBQIEE8mSMtDy2dj9EEBdXaQT9W3Rq1NS-jW8ebPoF
   6FyL0jIfATVE55zlircgOTZmEg1xeIrC3DsGegwjs4bhw14AQGKDlAXFFMyQkZegC
   wlbTlqX3F9HTt-lJxFU_pi16ezka7qVRCpSF0BQLfSqlsxMbYfSSCJX1BDtrIL7PX
   j__fUAAAECAEFA1BNUnP3te5WrwlEwiejEz0OpesmC5PElWc7kZ5nlLSqQTj1ciIp
   5vQ30LLUCyM_a2BYTUPKtd5EdS-PalT4t6ABADgeizRa5NkTMuX4zOdC-R4cLNWVV
   O8lLu2Psko-UJLR_XAH4Q0H7-m0_nQR1zBN78nYMKPvHsz8L3zWKRVyXEgAA

]]></artwork>
</figure>

    <t>
      The authorization
      server issues an access token and delivers it to the client
      by redirecting the user-agent with the following HTTP response:
    </t>

<figure title="Authorization Request" anchor="AuthzRespEx">
  <artwork><![CDATA[
 HTTP/1.1 302 Found
 Location: https://client.example.org/cb#state=rM8pZxG1c3gKy6rEbsD8s
   &expires_in=3600&token_type=Bearer
   &access_token=eyJhbGciOiJFUzI[...omitted for brevity...]8xy5W5sQ

]]></artwork>
</figure>


    <t>
      The access token is bound to the Referred Token Binding ID from
      the authorization request, which when
      represented as a JWT, as described in <xref target="Representation"/>,
      contains the SHA-256 hash of the
      Token Binding ID as the value of the <spanx style="verb">tbh</spanx> (token binding hash)
      member of the <spanx style="verb">cnf</spanx> (confirmation) claim. The confirmation claim
      portion of the JWT Claims Set is shown in the following figure.
    </t>

<figure title="Confirmation Claim" anchor="ATFromAuthzEndpoint">
  <artwork><![CDATA[
 {
   ...other claims omitted for brevity...
   "cnf":{
      "tbh": "vowQESa_MgbGJwIXaFm_BTN2QDPwh8PhuBm-EtUAqxc"
   }
 }

]]></artwork>
</figure>

        </section>
      </section>

      <section anchor="AccessTokenFromTokenEndpoint"
               title="Access Tokens Issued from the Token Endpoint">
	<t>
    For access tokens returned from the token endpoint,
    the Token Binding ID of the client's TLS channel to the protected resource
    is sent as the Referred Token Binding ID in the <spanx style="verb">Sec-Token-Binding</spanx> header.
    and used to bind the access token.
    This applies to all the conventional grant types from OAuth 2.0 <xref target="RFC6749"/>,
    including but not limited to refresh and authorization code token requests,
    as well as extension grants, such as JWT assertion authorization grants <xref target="RFC7523"/>.
	</t>
	<t>
    Upon receiving the Referred Token Binding ID
    the authorization server associates (binds) the
    ID with the access token in a way that can be retrieved by the protected
    resource. Such methods include embedding the Referred Token Binding ID (or a
    cryptographic hash of it) in the issued access token itself, or through
    token introspection <xref target="RFC7662"/>.  The exact method for
    associating the referred token binding ID is negotiated between the authorization 
    server and the protected resource, and is out of scope for this specification.
	</t>
	<t>
    Note that if the request results in a new refresh token being generated,
    it is bound using the Provided Token Binding ID, per
    <xref target="RefreshTokenBinding"/>
	</t>

        <section anchor="AccessTokenFromTokenEndpointEx"
                 title="Example Access Token Issued from the Token Endpoint">

    <t>
      This section provides an example of what the interactions around a
      Token Bound access token issued from the token endpoint might look
      like, along with some details of the involved processing.
      Extra line breaks in all examples are for display purposes only.
    </t>
    <t>
      The client makes an access token request to the token endpoint
      and includes the <spanx style="verb">Sec-Token-Binding</spanx> header
      with a Token Binding Message
      that contains both a Provided and Referred Token Binding ID. The Provided
      Token Binding ID is used to validate the token binding of the refresh token
      in the request (and to bind a new refresh token, if one is issued),
      and the Referred Token Binding ID is used to bind the access
      token that is generated.
      The base64url-encoded EKM
      from the TLS connection over which the access token request was made is
      <spanx style="verb">4jTc5e1QpocqPTZ5l6jsb6pRP18IFKdwwPvasYjn1-E</spanx>.
    </t>

          <figure title="Access Token Request" anchor="TokenEndpointRequestEx">
            <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: ARIAAgBBQJFXJir2w4gbJ7grBx9uTYWIrs9V50-PW4ZijegQ
   0LUM-_bGnGT6DizxUK-m5n3dQUIkeH7ybn6wb1C5dGyV_IAAQDDFToFrHt41Zppq7
   u_SEMF_E-KimAB-HewWl2MvZzAQ9QKoWiJCLFiCkjgtr1RrA2-jaJvoB8o51DTGXQ
   ydWYkAAAECAEFAuC1GlYU83rqTGHEau1oqvNwy0fDsdXzIyT_4x1FcldsMxjFkJac
   IBJFGuYcccvnCak_duFi3QKFENuwxql-H9ABAMcU7IjJOUA4IyE6YoEcfz9BMPQqw
   M5M6hw4RZNQd58fsTCCslQE_NmNCl9JXy4NkdkEZBxqvZGPr0y8QZ_bmAwAA

 refresh_token=gZR_ZI8EAhLgWR-gWxBimbgZRZi_8EAhLgWRgWxBimbf
  &grant_type=refresh_token&client_id=example-client-id

]]></artwork>
          </figure>

    <t>
      The authorization
      server issues an access token bound to the
      Referred Token Binding ID and delivers it in a response the client.
    </t>

          <figure title="Authorization Request" anchor="TokenEndpointRespEx">
            <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtp[...omitted...]1cs29j5c3",
  "token_type":"Bearer",
  "expires_in":3600
 }

]]></artwork>
          </figure>


  <t>
    The access token is bound to the Referred Token Binding ID of the
    access token request, which when
    represented as a JWT, as described in <xref target="Representation"/>,
    contains the SHA-256 hash of the
    Token Binding ID as the value of the <spanx style="verb">tbh</spanx> (token binding hash)
    member of the <spanx style="verb">cnf</spanx> (confirmation) claim. The confirmation claim portion
    of the JWT Claims Set of the access token is shown in the following figure.
  </t>

          <figure title="Confirmation Claim" anchor="ATFromTokenEndpoint">
            <artwork><![CDATA[
 {
   ...other claims omitted for brevity...
   "cnf":{
      "tbh": "7NRBu9iDdJlYCTOqyeYuLxXv0blEA-yTpmGIrAwKAws"
   }
 }

]]></artwork>
          </figure>

        </section>

      </section>

      <section anchor="Resource" title="Protected Resource Token Binding Validation">
	<t>
	  Upon receiving a token bound access token, the protected resource validates the binding
	  by comparing the Provided Token Binding ID
	  to the Token Binding ID for the access token.
	  Alternatively, cryptographic hashes of these Token Binding ID values can be compared.
	  If the values do not match, the resource access attempt MUST be rejected with an error.
	</t>
	<section anchor="ResourceExample" title="Example Protected Resource Request">
  <t>
    For example, a protected resource request using the access token from
    <xref target="AccessTokenFromTokenEndpointEx"/> would look something like the following.
    The base64url-encoded EKM
    from the TLS connection over which the request was made is
    <spanx style="verb">7LsNP3BT1aHHdXdk6meEWjtSkiPVLb7YS6iHp-JXmuE</spanx>.
    The protected resource validates the binding
    by comparing the Provided Token Binding ID from the
    <spanx style="verb">Sec-Token-Binding</spanx> header to the token binding hash
    confirmation of the access token. Extra line breaks in the example are for
    display purposes only.
  </t>
        <figure title="Protected Resource Request" anchor="ProtectedResourceRequestEc">
          <artwork><![CDATA[
 GET /api/stuff HTTP/1.1
 Host: resource.example.org
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: AIkAAgBBQLgtRpWFPN66kxhxGrtaKrzcMtHw7HV8yMk_-MdR
   XJXbDMYxZCWnCASRRrmHHHL5wmpP3bhYt0ChRDbsMapfh_QAQN1He3Ftj4Wa_S_fz
   ZVns4saLfj6aBoMSQW6rLs19IIvHze7LrGjKyCfPTKXjajebxp-TLPFZCc0JTqTY5
   _0MBAAAA

]]></artwork>
        </figure>
	</section>

      </section>

      <section anchor="Representation" title="Representing Token Binding in JWT Access Tokens">
	<t>
	  If the access token is represented as a JWT,
	  the token binding information SHOULD be represented in the same way
	  that it is in token bound OpenID Connect ID Tokens
	  <xref target="OpenID.TokenBinding"/>.
	  That specification defines the new JWT Confirmation Method
	  <xref target="RFC7800">RFC 7800</xref>
	  member <spanx style="verb">tbh</spanx> (token binding hash) 
	  to represent the SHA-256 hash of a Token Binding ID
	  in an ID Token.
	  The value of the <spanx style="verb">tbh</spanx> member is the
	  base64url encoding of the SHA-256 hash of the Token Binding ID.
	</t>
	<t>
	  The following example demonstrates the JWT Claims Set of an access token
	  containing the base64url encoding of the SHA-256 hash of a Token Binding ID
	  as the value of the <spanx style="verb">tbh</spanx> (token binding hash)
	  element in the <spanx style="verb">cnf</spanx> (confirmation) claim:
	</t>
	<figure title="JWT with Token Binding Hash Confirmation Claim" anchor="TBHJWT">
	  <artwork><![CDATA[
  {
   "iss": "https://server.example.com",
   "aud": "https://resource.example.org",
   "sub": "brian@example.com"
   "iat": 1467324320,
   "exp": 1467324920,
   "cnf":{
     "tbh": "7NRBu9iDdJlYCTOqyeYuLxXv0blEA-yTpmGIrAwKAws"
    }
  }

]]></artwork>
	</figure>

      </section>

    </section>

    <section anchor="AuthzCodeTokenBinding" title="Token Binding for Authorization Codes">
    <t>
      There are two variations for Token Binding of an authorization code.
      One is appropriate for native application clients and the other for web server clients.
      The nature of where the various components reside for the different client types
      demands different methods of Token Binding the authorization code so that it is bound to a Token Binding
      key on the end user's device. This ensures that a lost or stolen authorization code cannot be successfully
      utilized from a different device.
      For native application clients, the code is bound to a Token Binding key pair
      that the native client itself possesses.
      For web server clients, the code is bound to a Token Binding key pair on the end user's
      browser.
      Both variations utilize the extensible framework of
      <xref target="RFC7636">Proof Key for Code Exchange (PKCE)</xref>, which enables the
      client to show possession of a certain key when exchanging the authorization code for tokens.
      The following subsections individually describe each of the two PKCE methods respectively.
    </t>

      <section anchor="NativeAppClients" title="Native Application Clients">
        <t>
          This section describes a (PKCE) method suitable for native application clients
          that cryptographically binds the authorization code to a Token Binding key pair on the client,
          which the client proves possession of on the TLS connection during the access token request
          containing the authorization code.
          The authorization code is bound to the Token Binding ID that the native application
          client uses to resolve the authorization code at the token endpoint. This binding ensures that
          the client that made the authorization request is the same client that
          is presenting the authorization code.
        </t>
        <section anchor="NativeCodeChallenge" title="Code Challenge">
          <t>
            As defined in <xref target="RFC7636">Proof Key for Code Exchange</xref>,
            the client sends the code challenge as part of the OAuth 2.0
            authorization request with the two additional parameters:
            <spanx style="verb">code_challenge</spanx> and <spanx style="verb">code_challenge_method</spanx>.
          </t>
          <t>
            For this Token Binding method of PKCE, <spanx style='verb'>tb_s256</spanx>
            is used as the value of the <spanx style="verb">code_challenge_method</spanx> parameter.
          </t>
          <t>
            The value of the <spanx style="verb">code_challenge</spanx> parameter is the base64url encoding
            (per Section 5 of <xref target="RFC4648"/> with all trailing padding ('=')
            characters omitted and without the inclusion of any line breaks or whitespace)
            of the SHA-256 hash of the Provided Token Binding ID
            that the client will use when calling the authorization server's
            token endpoint. Note that, prior to making the authorization request, the client may need to
            establish a TLS connection between itself and the authorization server's token endpoint in order to establish
            the appropriate Token Binding ID.
          </t>
          <t>
            When the authorization server issues the authorization code in the authorization
            response, it associates the code challenge and method values
            with the authorization code so they can be verified later when the authorization code is
            presented in the access token request.
          </t>

	  <section anchor="NativeCodeChallengeExample" title="Example Code Challenge">

          <t>
            For example, a native application client sends an authorization request by
            sending the user's browser to the authorization endpoint. The resulting HTTP
            request looks something like the following (with extra line breaks for display purposes only).
          </t>

          <figure title="Authorization Request" anchor="NativeCodeChallengeEx">
            <artwork><![CDATA[
 GET /as/authorization.oauth2?response_type=code
   &client_id=example-native-client-id&state=oUC2jyYtzRCrMyWrVnGj
   &code_challenge=rBlgOyMY4teiuJMDgOwkrpsAjPyI07D2WsEM-dnq6eE
   &code_challenge_method=tb_s256 HTTP/1.1
 Host: server.example.com

]]></artwork>
          </figure>
	  </section>

        </section>

        <section anchor="NativeCodeVerifier" title="Code Verifier">
          <t>
            Upon receipt of the authorization code, the client sends the access
            token request to the token endpoint. The <xref target="I-D.ietf-tokbind-protocol">Token Binding Protocol</xref>
            is negotiated on the TLS connection between the client and the authorization server and the
            <spanx style="verb">Sec-Token-Binding</spanx> header, as defined in
            <xref target="I-D.ietf-tokbind-https">Token Binding over HTTP</xref>,
            is included in the access token request. The authorization server extracts the
            Provided Token Binding ID from the header value, hashes it with SHA-256, and compares
            it to the <spanx style="verb">code_challenge</spanx> value previously associated with the authorization code.
            If the values match, the token endpoint continues processing
            as normal (as defined by <xref target="RFC6749">OAuth 2.0</xref>).  If the values do not
            match, an error response indicating "invalid_grant" MUST be returned.
          </t>
          <t>
            The <spanx style="verb">Sec-Token-Binding</spanx> header contains sufficient information for verification of the
            authorization code and its association to the original authorization request. However, <xref target="RFC7636">PKCE</xref>
            requires that a <spanx style="verb">code_verifier</spanx> parameter be
            sent with the access token request, so the static value <spanx style="verb">provided_tb</spanx> is used to meet that
            requirement and indicate that the Provided Token Binding ID is used for the verification.
          </t>

	  <section anchor="NativeCodeVerifierExample" title="Example Code Verifier">
          <t>
            An example access token request, correlating to the authorization request in the previous example,
            to the token endpoint over a TLS connection for which
            Token Binding has been negotiated would look like the following (with extra line breaks for display purposes only).
            The base64url-encoded EKM
            from the TLS connection over which the request was made is
            <spanx style="verb">pNVKtPuQFvylNYn000QowWrQKoeMkeX9H32hVuU71Bs</spanx>.
          </t>

          <figure title="Authorization Request" anchor="NativeCodeVerifierEx">
<artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Sec-Token-Binding: AIkAAgBBQEOO9GRFP-LM0hoWw6-2i318BsuuUum5AL8bt1sz
   lr1EFfp5DMXMNW3O8WjcIXr2DKJnI4xnuGsE6GywQd9RbD0AQJDb3xyo9PBxj8M6Y
   jLt-6OaxgDkyoBoTkyrnNbLc8tJQ0JtXomKzBbj5qPtHDduXc6xz_lzvNpxSPxi42
   8m7wkAAA

 grant_type=authorization_code&code=mJAReTWKX7zI3oHUNd4o3PeNqNqxKGp6
   &code_verifier=provided_tb&client_id=example-native-client-id

]]></artwork>
          </figure>
	  </section>
        </section>
      </section>


      <section anchor="WebServerClients" title="Web Server Clients">
        <t>
          This section describes a (PKCE) method suitable for web server clients,
          which cryptographically binds the authorization code to a Token Binding
          key pair on the browser.
          The authorization code is bound to the Token Binding ID that the browser
          uses to deliver the authorization code to a web server client, which is sent to the
          authorization server as the Referred Token Binding ID during the authorization request.
          The web server client
          conveys the Token Binding ID to the authorization server when making
          the access token request containing the authorization code.
          This binding ensures that the authorization code cannot successfully be played or replayed to the
          web server client from a different browser than the one that made the authorization request.
        </t>
        <section anchor="WebCodeChallenge" title="Code Challenge">
          <t>
            As defined in <xref target="RFC7636">Proof Key for Code Exchange</xref>,
            the client sends the code challenge as part of the OAuth 2.0
            Authorization Request with the two additional parameters:
            <spanx style="verb">code_challenge</spanx> and <spanx style="verb">code_challenge_method</spanx>.
          </t>
          <t>
            The client must send the authorization request through the browser such that
            the Token Binding ID established between the browser and itself is revealed
            to the authorization server's authorization endpoint as the Referred Token Binding ID.
            Typically, this is done with an HTTP redirection response and the
            <spanx style="verb">Include-Referred-Token-Binding-ID</spanx> header, as defined in
            <xref target="I-D.ietf-tokbind-https">Section 5.3 of Token Binding over HTTP</xref>.
          </t>
          <t>
            For this Token Binding method of PKCE, <spanx style='verb'>rtb</spanx>
            is used for the value of the <spanx style="verb">code_challenge_method</spanx> parameter.
          </t>
          <t>
            The value of the <spanx style="verb">code_challenge</spanx> parameter is
            <spanx style='verb'>referred_tb</spanx>. The static value for the required PKCE
            parameter indicates that the authorization code is to be bound to the
            Referred Token Binding ID from the Token Binding Message sent in the
            <spanx style="verb">Sec-Token-Binding</spanx> header of the authorization request.
          </t>
          <t>
            When the authorization server issues the authorization code in the authorization
            response, it associates the Token Binding ID (or hash thereof) and code challenge method
            with the authorization code so they can be verified later when the authorization code is
            presented in the access token request.
          </t>

	  <section anchor="WebCodeChallengeExample" title="Example Code Challenge">
          <t>
            For example, the web server client sends the authorization request by
            redirecting the browser to the authorization endpoint. That HTTP redirection
            response looks like the following (with extra line breaks for display purposes only).
          </t>

          <figure title="Redirect the Browser" anchor="WebCodeChallenge302Ex">
            <artwork><![CDATA[
 HTTP/1.1 302 Found
 Location: https://server.example.com?response_type=code
   &client_id=example-web-client-id&state=P4FUFqYzs1ij3ffsYCP34d3
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb
   &code_challenge=referred_tb&code_challenge_method=rtb
 Include-Referred-Token-Binding-ID: true

]]></artwork>
          </figure>

          <t>
            The redirect includes the <spanx style="verb">Include-Referred-Token-Binding-ID</spanx>
            response header field that signals to the user-agent that it
            should reveal, to the authorization server, the Token Binding ID used
            on the connection to the web server client. The resulting HTTP request to the
            authorization server looks something like the following
            (with extra line breaks for display purposes only). The base64url-encoded EKM
            from the TLS connection over which the request was made is
            <spanx style="verb">7gOdRzMhPeO-1YwZGmnVHyReN5vd2CxcsRBN69Ue4cI</spanx>.

          </t>


          <figure title="Authorization Request" anchor="WebCodeChallengeEx">
            <artwork><![CDATA[
 GET /as/authorization.oauth2?response_type=code
   &client_id=example-web-client-id&state=dryo8YFpWacbUPjhBf4Nvt51
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb
   &code_challenge=referred_tb&code_challenge_method=rtb HTTP/1.1
 Host: server.example.com
 Sec-Token-Binding: ARIAAgBBQB-XOPf5ePlf7ikATiAFEGOS503lPmRfkyymzdWw
   HCxl0njjxC3D0E_OVfBNqrIQxzIfkF7tWby2ZfyaE6XpwTsAQBYqhFX78vMOgDX_F
   d_b2dlHyHlMmkIz8iMVBY_reM98OUaJFz5IB7PG9nZ11j58LoG5QhmQoI9NXYktKZ
   RXxrYAAAECAEFAdUFTnfQADkn1uDbQnvJEk6oQs38L92gv-KO-qlYadLoDIKe2h53
   hSiKwIP98iRj_unedkNkAMyg9e2mY4Gp7WwBAeDUOwaSXNz1e6gKohwN4SAZ5eNyx
   45Mh8VI4woL1BipLoqrJRoK6dxFkWgHRMuBROcLGUj5PiOoxybQH_Tom3gAA

]]></artwork>
          </figure>
	  </section>


        </section>

        <section anchor="WebCodeVerifier" title="Code Verifier">

          <t>
            The web server client receives the authorization code from the browser and
            extracts the Provided Token Binding ID from the
            <spanx style="verb">Sec-Token-Binding</spanx> header of the request.
            The client sends the base64url-encoded
            (per Section 5 of <xref target="RFC4648"/> with all trailing padding ('=')
            characters omitted and without the inclusion of any line breaks or whitespace)
            Provided Token Binding ID as the value of the
            <spanx style="verb">code_verifier</spanx> parameter in the access token request
            to the authorization server's token endpoint.


            The authorization server compares the value of the
            <spanx style="verb">code_verifier</spanx> parameter
            to the Token Binding ID value previously associated with the authorization code.
            If the values match, the token endpoint continues processing
            as normal (as defined by <xref target="RFC6749">OAuth 2.0</xref>).  If the values do not
            match, an error response indicating "invalid_grant" MUST be returned.
          </t>

	  <section anchor="WebCodeVerifierExample" title="Example Code Verifier">
          <t>
            Continuing the example from the previous section, the authorization server
            sends the code to the web server client by redirecting the browser to
            the client's <spanx style="verb">redirect_uri</spanx>, which results in the browser
            making a request like the following (with extra line breaks for display purposes only)
            to the web server client over a TLS channel for which Token Binding has been established.
            The base64url-encoded EKM
            from the TLS connection over which the request was made is
            <spanx style="verb">EzW60vyINbsb_tajt8ij3tV6cwy2KH-i8BdEMYXcNn0</spanx>.
          </t>
          <figure title="Authorization Response to Web Server Client" anchor="WebCodeVerifierRespEx">
<artwork><![CDATA[
 GET /cb?state=dryo8YFpWacbUPjhBf4Nvt51&code=jwD3oOa5cQvvLc81bwc4CMw
 Host: client.example.org
 Sec-Token-Binding: AIkAAgBBQHVBU530AA5J9bg20J7yRJOqELN_C_doL_ijvqpW
   GnS6AyCntoed4UoisCD_fIkY_7p3nZDZADMoPXtpmOBqe1sAQEwgC9Zpg7QFCDBib
   6GlZki3MhH32KNfLefLJc1vR1xE8l7OMfPLZHP2Woxh6rEtmgBcAABubEbTz7muNl
   Ln8uoAAA
]]></artwork>
          </figure>

          <t>
            The web server client takes the Provided Token Binding ID from the
            above request from the browser and sends it, base64url encoded, to the
            authorization server in the <spanx style="verb">code_verifier</spanx>
            parameter of the authorization code grant type request.
            Extra line breaks in the example request are for display purposes only.
          </t>
          <figure title="Exchange Authorization Code" anchor="WebCodeVerifierTokenReqEx">
<artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: server.example.com
 Content-Type: application/x-www-form-urlencoded
 Authorization: Basic b3JnLmV4YW1wbGUuY2xpZW50OmlldGY5OGNoaWNhZ28=

 grant_type=authorization_code&code=jwD3oOa5cQvvLc81bwc4CMw
   &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Eorg%2Fcb
   &client_id=example-web-client-id
   &code_verifier=AgBBQHVBU530AA5J9bg20J7yRJOqELN_C_doL_ijv
   qpWGnS6AyCntoed4UoisCD_fIkY_7p3nZDZADMoPXtpmOBqe1s
]]></artwork>
          </figure>
	  </section>

        </section>
      </section>

    </section>

    <section anchor="Phasing" title="Phasing in Token Binding and Preventing Downgrade Attacks">
      <t>
	Many OAuth implementations will be deployed in situations in which
	not all participants support Token Binding.
	Any of combination of the client, the authorization server, the protected resource,
	and the user agent may not yet support Token Binding,
	in which case it will not work end-to-end.
      </t>
      <t>
	It is a context-dependent deployment choice whether to allow
	interactions to proceed in which Token Binding is not supported
	or whether to treat Token Binding failures at any step as fatal errors.
	Particularly in dynamic deployment environments in which End Users have choices
	of clients, authorization servers, protected resources, and/or user agents,
	it is RECOMMENDED that authorizations using one or more components
	that do not implement Token Binding be allowed to successfully proceed.
	This enables different components to be upgraded to supporting Token Binding
	at different times, providing a smooth transition path for
	phasing in Token Binding.
	However, when Token Binding has been performed,
	any Token Binding key mismatches MUST be treated as fatal errors.
      </t>
      <t>
	If all the participants in an authorization interaction
	support Token Binding and yet one or more of them does not use it,
	this is likely evidence of a downgrade attack.
	In this case, the authorization SHOULD be aborted with an error.
	For instance, if the protected resource knows that the authorization server and the user agent both
	support Token Binding and yet the access token received does not contain
	Token Binding information, this is almost certainly a sign of an attack.
      </t>
      <t>
	The authorization server, client, and protected resource
	can determine whether the others support Token Binding
	using the metadata values defined in the next section.
	They can determine whether the user agent supports Token Binding
	by whether it negotiated Token Binding for the TLS connection.
      </t>
    </section>

    <section anchor="Metadata" title="Token Binding Metadata">
      <section anchor="ClientMetadata" title="Token Binding Client Metadata">
	<t>
	  Clients supporting Token Binding that also support
	  the <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref>
	  use these metadata values to declare their support for Token Binding
	  of access tokens and refresh tokens:
	</t>
	<t>
	  <list style="hanging">
	    <t hangText="client_access_token_token_binding_supported">
	      <vspace/>
	      OPTIONAL.
	      Boolean value specifying whether the client supports Token Binding of access tokens.
	      If omitted, the default value is <spanx style="verb">false</spanx>.
	    </t>
	    <t hangText="client_refresh_token_token_binding_supported">
	      <vspace/>
	      OPTIONAL.
	      Boolean value specifying whether the client supports Token Binding of refresh tokens.
	      If omitted, the default value is <spanx style="verb">false</spanx>.
	    </t>
	  </list>
	</t>
      </section>

      <section anchor="ASMetadata" title="Token Binding Authorization Server Metadata">
	<t>
	  Authorization servers supporting Token Binding that also support
	  <xref target="OAuth.AuthorizationMetadata">OAuth 2.0 Authorization Server Metadata</xref>
	  use these metadata values to declare their support for Token Binding
	  of access tokens and refresh tokens:
	</t>
	<t>
	  <list style="hanging">
	    <t hangText="as_access_token_token_binding_supported">
	      <vspace/>
	      OPTIONAL.
	      Boolean value specifying whether the authorization server supports Token Binding of access tokens.
	      If omitted, the default value is <spanx style="verb">false</spanx>.
	    </t>
	    <t hangText="as_refresh_token_token_binding_supported">
	      <vspace/>
	      OPTIONAL.
	      Boolean value specifying whether the authorization server supports Token Binding of refresh tokens.
	      If omitted, the default value is <spanx style="verb">false</spanx>.
	    </t>
	  </list>
	</t>
      </section>

      <section anchor="ResourceMetadata" title="Token Binding Protected Resource Metadata">
	<t>
	  Protected resources supporting Token Binding that also support
	  the <xref target="OAuth.ResourceMetadata">OAuth 2.0 Protected Resource Metadata</xref>
	  use this metadata value to declare their support for Token Binding
	  of access tokens:
	</t>
	<t>
	  <list style="hanging">
	    <t hangText="resource_access_token_token_binding_supported">
	      <vspace/>
	      OPTIONAL.
	      Boolean value specifying whether the protected resource supports Token Binding of access tokens.
	      If omitted, the default value is <spanx style="verb">false</spanx>.
	    </t>
	  </list>
	</t>
      </section>

    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
	If a refresh request is received by the authorization server containing a
	Referred Token Binding ID and the refresh token in the request
	is not itself token bound, then it is not clear that token binding
	the access token adds significant value.
	This situation should be considered an open issue for discussion by the working group.
      </t>
    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section anchor="DynRegRegistration" title="OAuth Dynamic Client Registration Metadata Registration">
	<t>
	  This specification registers the following client metadata definitions
	  in the IANA "OAuth Dynamic Client Registration Metadata" registry
	  <xref target="IANA.OAuth.Parameters"/>
	  established by <xref target="RFC7591"/>:
	</t>

	<section anchor="DynRegContents" title="Registry Contents">
	  <t>
	    <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Client Metadata Name: <spanx style="verb">client_access_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Client Metadata Description:
		Boolean value specifying whether the client supports Token Binding of access tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ClientMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		Client Metadata Name: <spanx style="verb">client_refresh_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Client Metadata Description:
		Boolean value specifying whether the client supports Token Binding of refresh tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ClientMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section anchor="ASMetadataRegistration" title="OAuth Authorization Server Metadata Registration">
	<t>
	  This specification registers the following metadata definitions
	  in the IANA "OAuth Authorization Server Metadata" registry
	  <!-- <xref target="IANA.OAuth.Parameters"/> TBD Uncomment once registry has been established -->
	  established by <xref target="OAuth.AuthorizationMetadata"/>:
	</t>

	<section anchor="ASMetadataContents" title="Registry Contents">
	  <t>
	    <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Metadata Name: <spanx style="verb">as_access_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Metadata Description:
		Boolean value specifying whether the authorization server supports Token Binding of access tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ASMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>
		Metadata Name: <spanx style="verb">as_refresh_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Metadata Description:
		Boolean value specifying whether the authorization server supports Token Binding of refresh tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ASMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section anchor="ResourceMetadataRegistration" title="OAuth Protected Resource Metadata Registration">
	<t>
	  This specification registers the following client metadata definition
	  in the IANA "OAuth Protected Resource Metadata" registry
	  <!-- <xref target="IANA.OAuth.Parameters"/> TBD Uncomment once registry has been established -->
	  established by <xref target="OAuth.ResourceMetadata"/>:
	</t>

	<section anchor="ResourceMetadataContents" title="Registry Contents">
	  <t>
	    <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>
		Resource Metadata Name: <spanx style="verb">resource_access_token_token_binding_supported</spanx>
	      </t>
	      <t>
		Resource Metadata Description:
		Boolean value specifying whether the protected resource supports Token Binding of access tokens
	      </t>
	      <t>
		Change Controller: IESG
	      </t>
	      <t>
		Specification Document(s): <xref target="ResourceMetadata"/> of [[ this specification ]]
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>
      <section anchor="PKCEMethodRegistration" title="PKCE Code Challenge Method Registration">

        <t>
          This specification requests registration of the following
          Code Challenge Method Parameter Names
          in the IANA "PKCE Code Challenge Methods" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC7636"/>.
        </t>

        <section anchor="PKCEMethodContents" title='Registry Contents'>

          <?rfc subcompact="yes"?>
          <t>
            <list style='symbols'>
              <t>Code Challenge Method Parameter Name: tb_s256</t>
              <t>Change controller: IESG</t>
              <t>Specification document(s): <xref target="NativeCodeChallenge"/> of [[ this specification ]]</t>
            </list>
          </t>
          <t>
            <list style='symbols'>
              <t>Code Challenge Method Parameter Name: rtb</t>
              <t>Change controller: IESG</t>
              <t>Specification document(s): <xref target="WebCodeChallenge"/> of [[ this specification ]]</t>
            </list>
          </t>
          <?rfc subcompact="no"?>

        </section>
      </section>



    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648"?>  <!-- base64 -->
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7636"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7662"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7800"?>


      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tokbind-protocol-13.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tokbind-https-08.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tokbind-negotiation-07.xml' ?>



      <reference anchor="OpenID.TokenBinding" target="http://openid.net/specs/openid-connect-token-bound-authentication-1_0.html">
        <front>
          <title>OpenID Connect Token Bound Authentication 1.0</title>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
          </author>

	  <author fullname="Brian Campbell" initials="B." surname="Campbell">
	    <organization>Ping Identity</organization>
	  </author>

          <date day="4" month="July" year="2016"/>
        </front>
      </reference>

      <reference anchor="OAuth.AuthorizationMetadata" target="http://tools.ietf.org/html/draft-ietf-oauth-discovery-06">
        <front>
	  <title>OAuth 2.0 Authorization Server Metadata</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	    <address>
	      <email>n-sakimura@nri.co.jp</email>
	      <uri>http://nat.sakimura.org/</uri>
	    </address>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	    <address>
	      <email>ve7jtb@ve7jtb.com</email>
	      <uri>http://www.thread-safe.com/</uri>
	    </address>
	  </author>

	  <date day="10" month="March" year="2017" />
        </front>
	<seriesInfo name="Internet-Draft" value="draft-ietf-oauth-discovery-06"/>
      </reference>

      <reference anchor="OAuth.ResourceMetadata" target="http://tools.ietf.org/html/draft-jones-oauth-resource-metadata-01">
        <front>
	  <title abbrev="OAuth 2.0 Protected Resource Metadata">OAuth 2.0 Protected Resource Metadata</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	    <address>
	      <email>mbj@microsoft.com</email>
	      <uri>http://self-issued.info/</uri>
	    </address>
	  </author>

	  <author fullname="Phil Hunt" initials="P." surname="Hunt">
	    <organization>Oracle</organization>
	    <address>
	      <email>phil.hunt@yahoo.com</email>
	    </address>
	  </author>

	  <date day="19" month="January" year="2017" />
        </front>
	<seriesInfo name="Internet-Draft" value="draft-jones-oauth-resource-metadata-01"/>
      </reference>

      <reference anchor="JWT" target="http://tools.ietf.org/html/rfc7519">
	<front>
	  <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <date month="May" year="2015" />
	</front>

	<seriesInfo name="RFC" value="7519"/>
	<seriesInfo name="DOI" value="10.17487/RFC7519"/>
      </reference>

      <reference anchor="SHS" target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
        <front>
          <title>Secure Hash Standard (SHS)</title>

          <author>
            <organization>National Institute of Standards and
            Technology</organization>
          </author>

          <date month="March" year="2012" />
        </front>
        <seriesInfo name="FIPS" value="PUB 180-4" />
        <format target="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf" type="PDF" />
      </reference>

      <reference anchor="IANA.OAuth.Parameters" target="http://www.iana.org/assignments/oauth-parameters">
        <front>
          <title>OAuth Parameters</title>
          <author>
            <organization>IANA</organization>
          </author>
	  <date/>
        </front>
      </reference>

    </references>

    <references title="Informative References">
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7591"?>
      <?rfc include="http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7523"?>

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-native-apps-08.xml' ?>

      <reference anchor="OpenID.Core" target="http://openid.net/specs/openid-connect-core-1_0.html">
        <front>
          <title>OpenID Connect Core 1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
            <organization abbrev="Google">Google</organization>
          </author>

	  <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
	    <organization abbrev="Salesforce">Salesforce</organization>
	  </author>

          <date day="8" month="November" year="2014"/>
        </front>
      </reference>

    </references>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
	The authors would like to thank the following people for their contributions to the specification:
	Dirk Balfanz,
	William Denniss,
	Andrei Popov,
	and
	Nat Sakimura.
      </t>
    </section>

    <section anchor="TBD" title="Open Issues">
      <t>
	<list style="symbols">
	  <t>
	    What should we do in the case that a refresh request for a token bound access token
	    is received when the refresh token used in the request is not token bound?
	  </t>
    <t>
      Should the scope of this document include standardizing or recommending how to convey token binding
      information of an access token via RFC 7662 OAuth 2.0 Token Introspection?
    </t>
    <t>
      Should the scope of this document include standardization or guidance on token binding
      of JWT Client Authentication and/or Authorization Grants from RFC 7523?
    </t>
    <t>
      The <xref target="Metadata">Metadata</xref> and
      <xref target="Phasing">what can and cannot be reliably inferred from it</xref>
      need additional evaluation and work.
      <xref target="OAuth.ResourceMetadata">OAuth 2.0 Protected Resource Metadata</xref>
      is no longer a going concern, but is currently referenced herein.
      Boolean values do not adequately convey Token Binding support, as different components may support
      different key parameters types.
      And successful negotiation likely doesn't provide the application layer info about
      all the supported key parameters types but rather just the one that was negotiated.
    </t>
        </list>
      </t>
    </section>

    <section anchor="History" title="Document History">
      <t>[[ to be removed by the RFC Editor before publication as an RFC ]]</t>

      <t>
	-02
	<list style="symbols">
	  <t>Added a section on Token Binding for authorization codes with one variation for native clients and one for web server clients.</t>
	  <t>Updated language to reflect that the binding is to the token binding key pair and that proof-of-possession of that key is done on the TLS connection.</t>
	  <t>Added a bunch of examples.</t>
    <t>Added a few Open Issues so they are tracked in the document.</t>
	  <t>Updated Token Binding references.</t>
	</list>
      </t>

      <t>
	-01
        <list style="symbols">
	  <t>
	    Changed Token Binding for access tokens to use the Referred Token Binding ID,
	    now that the Implementation Considerations in the Token Binding HTTPS specification
	    make it clear that implementations will enable using the Referred Token Binding ID.
	  </t>
	  <t>
	    Defined Protected Resource Metadata value.
	  </t>
	  <t>
	    Changed to use the more specific term "protected resource" instead of "resource server".
	  </t>
	</list>
      </t>

      <t>
	-00
        <list style="symbols">
	  <t>
	    Created the initial working group version from draft-jones-oauth-token-binding-00.
	  </t>
	</list>
      </t>

    </section>

  </back>
</rfc>
